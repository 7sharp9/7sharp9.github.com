<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Async on 7sharp9</title><link>https://7sharp9.dev/tags/async/</link><description>Recent content in Async on 7sharp9</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Dave Thomas</copyright><lastBuildDate>Wed, 05 Jun 2013 00:00:00 +0000</lastBuildDate><atom:link href="https://7sharp9.dev/tags/async/index.xml" rel="self" type="application/rss+xml"/><item><title>Monster Zero - Revisited</title><link>https://7sharp9.dev/fsharp/2013-06-05-monster-zero-revisited/</link><pubDate>Wed, 05 Jun 2013 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/2013-06-05-monster-zero-revisited/</guid><description>This creature is capable of tremendous destruction due to it&amp;rsquo;s size, flight (with the creature&amp;rsquo;s wings also generating hurricane strength winds) and possesses several breath weapons (e.g., heat and energy).
What am I talking about here? Maybe it&amp;rsquo;s Monster Zero or King Ghidorah as it&amp;rsquo;s sometimes known. No it&amp;rsquo;s TPL Dataflow! Yeah, yeah, I have a penchant for being over dramatic and writing quirky intros. This post is about TPL Dataflow otherwise known as TDF.</description></item><item><title>I node something (Bout You)</title><link>https://7sharp9.dev/fsharp/2013-05-05-i-node-something/</link><pubDate>Sun, 05 May 2013 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/2013-05-05-i-node-something/</guid><description>What is Edge.js? Unless you live in a hole you have probably heard of node.js so I&amp;rsquo;ll not bother to explain what it is or what it does. An interesting project has come to light lately, namely Edge.js. The Edge.js project allows you to connect node.js with .Net.
The creator of Edge.js Tomasz Janczuk sums this up nicely:
An edge connects two nodes
This edge connects node.js with .</description></item><item><title>iOS async revisited</title><link>https://7sharp9.dev/fsharp/2013-04-18-ios-async-revisited/</link><pubDate>Thu, 18 Apr 2013 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/2013-04-18-ios-async-revisited/</guid><description>In this post weare going to look as async again, but from the perspective of F#.
Xamarin Evolve 2013 I have been watching the Xamarin Evolve conference this week and it was good to see Miguel announce full support for F#. Those that follow me on twitter etc, will know that I have been doing F# for quite a while in MonoDevelop and Xamarin Studio. The new support currently entails some new project templates so that you can easily create epic new F# Apps without having to refer to my blog.</description></item><item><title>A little bit of iOS async</title><link>https://7sharp9.dev/fsharp/2013-04-16-a-little-bit-of-ios-async/</link><pubDate>Tue, 16 Apr 2013 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/2013-04-16-a-little-bit-of-ios-async/</guid><description>I was going to title this post as &amp;lsquo;Now for something completely different&amp;rsquo; but felt that a little bit too Pythonesque, and when I thought about it a bit it isn&amp;rsquo;t really completely just slightly different, namely C# rather than my usual F# posts. Right, enough of the waffling, this post is a little tour into the relatively unknown area of async on iOS. Xamarin announced the alpha preview of async await on March 11th this year (2013).</description></item><item><title>The Lurking Horror</title><link>https://7sharp9.dev/fsharp/the-lurking-horror/</link><pubDate>Sun, 15 Jul 2012 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/the-lurking-horror/</guid><description>Deep in the darkest depths lurks an ancient horror, when the time is right it will rise forth and leave you screaming for mercy and begging for forgiveness&amp;hellip;
OK, I have a penchant for being over dramatic but in this post I am going to reveal some little known caveats in a well known and much revelled area of F#, agents aka the MailboxProcessor. Gasp!
First let me give you a demonstration:</description></item><item><title>Back to the Primitive II</title><link>https://7sharp9.dev/fsharp/back-to-the-primitive-ii/</link><pubDate>Sun, 22 Apr 2012 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/back-to-the-primitive-ii/</guid><description>In the last post I discussed an asynchronous version of the ManualResetEvent and as promised this time we will be looking at an asynchronous version of the AutoResetEvent. I&amp;rsquo;m using Stephen Toubs post as reference and we will be building a version that is functional in style that maps straight into asynchronous work flows without and conversion or adaptors.
What is an AutoResetEvent? An AutoResetEvent can be described as a turnstile mechanism, it lets a single waiting person through before re-latching waiting for the next signal.</description></item><item><title>Back to the Primitive</title><link>https://7sharp9.dev/fsharp/back-to-the-primitive/</link><pubDate>Thu, 12 Apr 2012 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/back-to-the-primitive/</guid><description>In this post we are going back to the primitive. No it&amp;rsquo;s not about the same named song by Soulfly, (which incidentally does contains F# notes) but a return to thread synchronisation primitives and their asynchronous counterparts.
We are going to be looking at an asynchronous version of the ManualResetEvent. This was recently covered by Stephen Toub on the pfx team blog. We will be taking a slightly different view on this as we will be using asynchronous workflows which will give us nice idiomatic usage within F#.</description></item><item><title>FSharp Dataflow agents III</title><link>https://7sharp9.dev/fsharp/fsharp-dataflow-agents-iii/</link><pubDate>Mon, 20 Feb 2012 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/fsharp-dataflow-agents-iii/</guid><description>This will be the last post on rebuilding the MailboxProcessor using TDF, here&amp;rsquo;s a quick discussion of the missing pieces&amp;hellip;
First, lets start with the simple ones, these don&amp;rsquo;t really require much discussion.
DefaultTimeout let mutable defaultTimeout = Timeout.Infinite member x.DefaultTimeout with get() = defaultTimeout and set(value) = defaultTimeout &amp;lt;- value This simply provides a mutable property using Timeout.Infinite as a default setting.
CurrentQueueLength member x.CurrentQueueLength() = incomingMessages.Count Another simple one, this methods uses into the underlying BufferBlock to extract its current queue length using its Count property.</description></item><item><title>F# Dataflow Agents Part II</title><link>https://7sharp9.dev/fsharp/fsharp-dataflow-agents-ii/</link><pubDate>Mon, 30 Jan 2012 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/fsharp-dataflow-agents-ii/</guid><description>Right, no messing about this time, straight to the code.
Construction This is pretty straight forward and I don&amp;rsquo;t want to detract from the important bits of this post, the only thing of note is the cancellationToken which is initialized to a default value using the defaultArg function if the optional parameter cancellationToken is not supplied. The TDF construct that we to use to perform most of the hard work is incomingMessages which is a BufferBlock&amp;lt;'Msg&amp;gt;.</description></item><item><title>F# Dataflow Agents Part I</title><link>https://7sharp9.dev/fsharp/fsharp-dataflow-agents-i/</link><pubDate>Sun, 22 Jan 2012 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/fsharp-dataflow-agents-i/</guid><description>This is going to be a new series on using TPL Dataflow with F#. First a little bit of history and background.
TPL Dataflows heritage and background TPL Dataflow or (TDF) has been around for quite a while, it first surfaced more than a year ago as the successor to the Concurrency and Coordination Runtime (CCR) and with coming release of .Net 4.5 it will be part of the System.Threading.Tasks.Dataflow namespace.</description></item><item><title>Fixing a hole...</title><link>https://7sharp9.dev/fsharp/fixing-a-hole/</link><pubDate>Sun, 11 Dec 2011 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/fixing-a-hole/</guid><description>Due to popular demand&amp;hellip; well, I had a couple of requests anyway :-) Heres a post inspired by my recent encounters profiling some of the code in Fracture-IO. I have recently been profiling the code in fracture to remove any so called low hanging fruits. During this time I also noticed an increase in memory allocation. I remembered I had recently been experimenting in a branch using pipelets as a buffer between the send and receive stages in the Http Server, so I set up a simple test to see if pipelets were contributing to the memory allocation issues I was seeing.</description></item><item><title>Agent based scheduling</title><link>https://7sharp9.dev/fsharp/agent-based-scheduling/</link><pubDate>Sun, 03 Jul 2011 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/agent-based-scheduling/</guid><description>One of the areas that I am very interested in is agents and I have been doing quite a lot of work in this area lately.
Agents can be used for a multitude of different purposes ranging from: isolated message passing, object caching, finite state machines, web crawling, and even reactive user interfaces. One of the ideas that I have been looking into lately is agent based scheduling.SchedulerAgent A simple Agent based scheduler:</description></item><item><title> Agents and ObjectPools</title><link>https://7sharp9.dev/fsharp/agents-and-objectpools/</link><pubDate>Sun, 05 Jun 2011 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/agents-and-objectpools/</guid><description>Everyone knows F# agents are cool right? Well here&amp;rsquo;s yet another example of how versatile they can be&amp;hellip;
There was a series of posts last April by Stephen Toub from the pfxteam at Microsoft. I was reading through some of the posts again the other day and thought some of the ideas presented there would make interesting projects in F# to demonstrate the flexibility and succinctness of the language. I thought the ObjectPool example would make an interesting project in F# using agents aka MailboxProcessors.</description></item><item><title>Pipeline processing 3</title><link>https://7sharp9.dev/fsharp/pipeline-processing-3/</link><pubDate>Mon, 04 Apr 2011 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/pipeline-processing-3/</guid><description>Ok so I have been offline for a while now, what with starting a new financial contract in London and not having any broadband access for a while. I have been working on something, honest!
Since the last post I have been reflecting on the pipeline design and it had a distinct object orientated feel to it that I wasnt happy with, so I have amended the structure of the code and come up with the following which simplifies in some areas and expands in others&amp;hellip;module Pipeline open System.</description></item><item><title>Pipeline processing 2</title><link>https://7sharp9.dev/fsharp/pipeline-processing-2/</link><pubDate>Sun, 13 Feb 2011 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/pipeline-processing-2/</guid><description>Welcome to pipeline processing part 2. I feel I need to backtrack slightly from the previous post, having worked with pipelines for quite some time I have the advantage of knowing all of the details that may be alluded to in these articles without being effected by any omissions I may make, obviously you guys aren&amp;rsquo;t in that position, so I&amp;rsquo;m going to try and rectify that a bit now. If you have any queries then please leave a comment and I will try to address them in further articles.</description></item><item><title>Pipeline processing 1</title><link>https://7sharp9.dev/fsharp/pipeline-processing-1/</link><pubDate>Tue, 01 Feb 2011 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/pipeline-processing-1/</guid><description>Welcome to new series of articles on pipeline processing. First up, what&amp;rsquo;s a pipeline? Well according to Wikipedia:
A pipeline is a set of data processing elements connected in series, so that the output of one element is the input of the next one. The elements of a pipeline are often executed in parallel or in time-sliced fashion; in that case, some amount of buffer storage is often inserted between elements.</description></item><item><title>Sockets and Bockets 4</title><link>https://7sharp9.dev/fsharp/sockets-and-bockets-part-4/</link><pubDate>Fri, 28 Jan 2011 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/sockets-and-bockets-part-4/</guid><description>Welcome to part 4 If you were looking forward to some exciting new F# code this time your going to be disappointed, however if you are like me and like looking at graphs and stats and digging in deeper into the code then your going to enjoy this, lets get started&amp;hellip;I set up a 5 minute test with 50 clients connecting to the server with a 15ms interval between each one.</description></item><item><title>Sockets and Bockets 3</title><link>https://7sharp9.dev/fsharp/sockets-and-bockets-part-3/</link><pubDate>Thu, 20 Jan 2011 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/sockets-and-bockets-part-3/</guid><description>Welcome to part three! As promised heres a description of the inner workings. I&amp;rsquo;m sick to death of typing SocketAsyncEventArgs so from now on I will refer to it as SAEA.BocketPool
The BocketPool has an interesting name and with it an interesting constructor! It takes the following parameters:
number: The number of items to create in the BocketPool. size: The size of each buffer in bytes. callback: A callback function which is invoked whenever the SAEA object completes its operation.</description></item><item><title>Sockets and Bockets 2</title><link>https://7sharp9.dev/fsharp/sockets-and-bockets-part-2/</link><pubDate>Fri, 14 Jan 2011 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/sockets-and-bockets-part-2/</guid><description>Welcome to part two Lets jump in at the deep end and take a look at some code&amp;hellip;
When you look at the method syntax for the xxxAsync methods you will notice they return a boolean value that indicates if the method completed synchronously, this means that you have to check the return value every time you use one of the methods and invoke the callback yourself if it completes synchronously.</description></item><item><title>Sockets and Bockets 1</title><link>https://7sharp9.dev/fsharp/sockets-and-bockets-1/</link><pubDate>Thu, 13 Jan 2011 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/sockets-and-bockets-1/</guid><description>Welcome to part 1 A while back I read an interesting article by Brian McNamara f-async-on-the-server-side which describes C# and F# versions of a simple asynchronous socket server, one of the driving forces behind the article was how F# can wrap the traditional asynchronous model with Asynchronous Workflows, this produces nice clean simple code compared to the C# version which uses lambda expressions, the code looks quite ugly in this style!</description></item></channel></rss>