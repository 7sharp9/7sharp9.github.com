<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TPL on 7sharp9</title><link>https://7sharp9.dev/tags/tpl/</link><description>Recent content in TPL on 7sharp9</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Dave Thomas</copyright><lastBuildDate>Sun, 22 Apr 2012 00:00:00 +0000</lastBuildDate><atom:link href="https://7sharp9.dev/tags/tpl/index.xml" rel="self" type="application/rss+xml"/><item><title>Back to the Primitive II</title><link>https://7sharp9.dev/fsharp/back-to-the-primitive-ii/</link><pubDate>Sun, 22 Apr 2012 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/back-to-the-primitive-ii/</guid><description>In the last post I discussed an asynchronous version of the ManualResetEvent and as promised this time we will be looking at an asynchronous version of the AutoResetEvent. I&amp;rsquo;m using Stephen Toubs post as reference and we will be building a version that is functional in style that maps straight into asynchronous work flows without and conversion or adaptors.
What is an AutoResetEvent? An AutoResetEvent can be described as a turnstile mechanism, it lets a single waiting person through before re-latching waiting for the next signal.</description></item><item><title>Back to the Primitive</title><link>https://7sharp9.dev/fsharp/back-to-the-primitive/</link><pubDate>Thu, 12 Apr 2012 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/back-to-the-primitive/</guid><description>In this post we are going back to the primitive. No it&amp;rsquo;s not about the same named song by Soulfly, (which incidentally does contains F# notes) but a return to thread synchronisation primitives and their asynchronous counterparts.
We are going to be looking at an asynchronous version of the ManualResetEvent. This was recently covered by Stephen Toub on the pfx team blog. We will be taking a slightly different view on this as we will be using asynchronous workflows which will give us nice idiomatic usage within F#.</description></item><item><title>Pipeline processing 3</title><link>https://7sharp9.dev/fsharp/pipeline-processing-3/</link><pubDate>Mon, 04 Apr 2011 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/pipeline-processing-3/</guid><description>Ok so I have been offline for a while now, what with starting a new financial contract in London and not having any broadband access for a while.Â I have been working on something, honest!
Since the last post I have been reflecting on the pipeline design and it had a distinct object orientated feel to it that I wasnt happy with, so I have amended the structure of the code and come up with the following which simplifies in some areas and expands in others&amp;hellip;module Pipeline open System.</description></item><item><title>Pipeline processing 1</title><link>https://7sharp9.dev/fsharp/pipeline-processing-1/</link><pubDate>Tue, 01 Feb 2011 00:00:00 +0000</pubDate><guid>https://7sharp9.dev/fsharp/pipeline-processing-1/</guid><description>Welcome to new series of articles on pipeline processing. First up, what&amp;rsquo;s a pipeline? Well according to Wikipedia:
A pipeline is a set of data processing elements connected in series, so that the output of one element is the input of the next one. The elements of a pipeline are often executed in parallel or in time-sliced fashion; in that case, some amount of buffer storage is often inserted between elements.</description></item></channel></rss>