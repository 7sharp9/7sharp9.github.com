<!doctype html><html><head><title>Flux Compression (redux) &#183; 7sharp9</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=generator content="Hugo 0.82.1"><link rel=stylesheet href=https://7sharp9.dev/css/vec.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.ico><link href rel=alternate type=application/rss+xml title=7sharp9></head><body><header><nav><ul><li class=pull-left><a href=https://7sharp9.dev/>/Home</a></li><li class=pull-left><a href=/about>/About</a></li><li class=pull-left><a href=/fsharp>/F#</a></li><li class=pull-left><a href=/running>/Running</a></li><li class=pull-left><a href=/elm>/Elm</a></li><li class=pull-right><a href><i class="fas fa-rss"></i></a></li></ul></nav></header><div class="content wide"><section class=post><h1 class=post-title><a href=https://7sharp9.dev/fsharp/2014-11-05-flux-compression-redux/>Flux Compression (redux)</a></h1><span class=post-date>Nov 5, 2014</span><div class=post-content><p>First of all the title, redux because I&rsquo;m revising post I started on earlier in the year, compression because this has to do with compression, and Flux, which is also part of the redux, one of the first things I remember writing on the net was an article about Flux Compression Generators on <a href=http://www.h2g2.com>H2G2</a>, its still there too!</p><p>This was a post I started writing back in January that I never got round to finishing.</p><p>Once upon a time I had a need to quickly browse a zip file and it&rsquo;s Crc, so I quickly put together a <a href=http://msdn.microsoft.com/en-us/library/hh156509.aspx>Type Provider</a> as a way to help in this en-devour. I&rsquo;m going to split the code into a few section and run a commentary over each block so you can see what I did and why.</p><h1 id=zip-provider>Zip Provider</h1><p>I&rsquo;m going to use <a href=https://sharpcompress.codeplex.com>SharpCompress</a> as the basis for peering into zip files, you could also choose any other zip API. Essentially to open and peruse a zip the API consists of the following:</p><pre><code>let zipfile = SharpCompress.Archive.ArchiveFactory.Open(fileName)

for entry in zipFile.Entries do
	...
</code></pre><p>This gives us the ability to open a zip file and to iterate over its contents via a sequence of <code>IArchiveEntry</code></p><h2 id=creating-the-type-provider>Creating the Type Provider</h2><p>To create a Type Provider we need to create a type which looks like this, also notice the <code>TypeProviderAssembly</code> attribute:</p><pre><code>[&lt;TypeProvider&gt;]
type public ZipProvider(cfg : TypeProviderConfig) as this =
    inherit TypeProviderForNamespaces()

    let asm = Assembly.GetExecutingAssembly()
    let ns = &quot;Xebec&quot;
    let root = ProvidedTypeDefinition(asm, ns, &quot;ZipProvider&quot;, Some(typeof&lt;obj&gt;))
    let filePathParam = ProvidedStaticParameter(&quot;FilePath&quot;, typeof&lt;string&gt;)

    let buildTypes (typeName:string) (args:obj[]) =
        let fileName = args.[0] :?&gt; string
        ...

    do root.DefineStaticParameters ([filePathParam], buildTypes)
    do this.AddNamespace(ns, [root])
        
[&lt;TypeProviderAssembly&gt;]
do()
</code></pre><p>Assuming <code>buildTypes</code> is complete and working the following user code might be used to use the Type Provider:</p><pre><code>type myZip = Xebex.ZipProvider&lt;&quot;myfile.zip&quot;&gt;

let file1Crc = myZip.MyFile1.Crc
let file1Size = myZip.MyFile1.Size
</code></pre><p>I always try think how the Type Provider might be used before undertaking work like this, Type Providers are supposed to aid usability not hinder it. I&rsquo;m not a fan of big mechanistic design sessions and pencil pushing, I like to get into the field and working things out, that&rsquo;s just my way though.</p><h2 id=build-it-and-they-will-come>Build it and they will come</h2><p>Next we need to create types based on the output of SharpCompress. The property <code>zipFile.Entries</code> returns a sequence of <code>IArchiveEntry</code> which have properties such as <code>Size</code>, <code>Crc</code>, <code>FileName</code> etc, so we&rsquo;ll use these as we construct the type system.</p><p>One thing to be aware of with SharpCompress is the <code>Entries</code> properties returns a flat list of all the files in the archive. If you have a simple archive with only files at the root level then things are very simple. Once you move to an archive that has a complex directory hierarchy then things get a little trickier. One of the reasons is type namespace collisions, if we have file&rsquo;s with the same name but different directories then the type system needs to match this to avoid adding a type with the same name. It doesn&rsquo;t really make sense to have a flattened list anyway as I was using this provider to quickly peruse zip files from <a href=http://msdn.microsoft.com/en-us/library/dd233175.aspx>FSI</a>.</p><p>Here&rsquo;s the bulk of <code>buildTypes</code>:</p><pre><code>let buildTypes (typeName:string) (args:obj[]) =
    let fileName = args.[0] :?&gt; string
    let zipfile = SharpCompress.Archive.ArchiveFactory.Open(fileName)
    let zipType = ProvidedTypeDefinition(asm, ns, typeName, Some(typeof&lt;obj&gt;))

    ...

    for entry in zipfile.Entries do

        //we need to add types for each directory before adding the zipEntryType to the last occurrence
        let dirs = Path.getAllDirectories entry.FilePath
        let parent = processDirectories dirs zipType

        if entry.IsDirectory then
            parent.AddMembers &lt;| mkProperties entry
        else
            let zipEntry = ProvidedTypeDefinition(safeTypeName entry.FilePath, Some(typeof&lt;obj&gt;))
            zipEntry.AddMembers &lt;| mkProperties entry
            parent.AddMember(zipEntry)

    zipType
</code></pre><p>There are a few parts of code missing, but I&rsquo;ll get to those in a second. You can see we create a root type to hold the type system that will represent the zip file:</p><pre><code>let zipType = ProvidedTypeDefinition(asm, ns, typeName, Some(typeof&lt;obj&gt;))
</code></pre><p>SharpCompress is then used to open the archive and loop over the entries. For each file entry found we create a <code>ProvidedTypeDefinition</code> and corresponding properties and add it to the parent, but for each directory we only add properties to an existing ProvidedType.</p><p>The important functions missing here are <code>mkProperties</code>, <code>getAllDirectories</code> and <code>processDirectories</code></p><h3 id=mkproperties>mkProperties</h3><p><code>mkProperties</code> is the meat and potatoes here:</p><pre><code>let mkProperties (entry:IArchiveEntry) = 
    [yield PP.MkStatic (&quot;FilePath&quot;, fun _ -&gt; Expr.Value entry.FilePath)
     if not entry.IsDirectory then yield PP.MkStatic (&quot;Crc&quot;, fun _ -&gt; Expr.Value entry.Crc)
     yield PP.MkStatic (&quot;PackedSize&quot;, fun _ -&gt; Expr.Value entry.CompressedSize)
     yield PP.MkStatic (&quot;Size&quot;, fun _ -&gt; Expr.Value entry.Size)
     yield PP.MkStatic (&quot;CompressionRatio&quot;, fun _ -&gt; Expr.Value (float entry.Size / float entry.CompressedSize))
     yield PP.MkStatic (&quot;SpaceSavings&quot;, fun _ -&gt; Expr.Value (1.0 - float entry.CompressedSize / float entry.Size))]
</code></pre><p>This function take a <code>IArchiveEntry</code> and returns a bunch of <code>ProvidedProperties</code>, one for each property we are interested in exposing in our type system. <code>PP</code> is a <a href=http://msdn.microsoft.com/en-us/library/dd233246.aspx>Type Abbreviation</a> for <code>ProvidedProperty</code>, <code>MkStatic</code> is a <a href=http://msdn.microsoft.com/en-us/library/dd233211.aspx>Type Extension</a>, these will both explained further on. In this function we are creating a list comprehension with each of the properties we want to represent. <code>MkStatic</code> is just a wrapper around the <code>ProvidedProperty</code> constructor, each property has a name, type and the getter function as represented by an expression. In this instance our expression is just the value of the property in <code>IArchiveEntry</code> so we represent this with <code>Expr.Value entry.x</code>. You might of been tempted to write this expression as &lt;@@ entry.x @@> which uses the <a href=http://msdn.microsoft.com/en-us/library/dd233212.aspx>Untyped Quotation</a> syntax but this would of resulted in an error from the compiler when in use. This is to do with type erasure, and the fact that only simple types can be represented as values in the quotation blocks. There&rsquo;s a <a href=http://stackoverflow.com/questions/10161437/type-provider-providing-me-with-an-unsuported-constant-type-system-double-er>stackoverflow question</a> that covers this too. The last two properties and not simple properties but calculations, that&rsquo;s one of the beauties of Type Providers, you can easily leverage an existing API and make it more usable for your domain.</p><h3 id=getalldirectories>getAllDirectories</h3><p><code>getAllDirectories</code> is a module that extends <code>Path</code> so that a list of directory elements are returned for a path string. e.g. &ldquo;/Users/dave/test&rdquo; would yield [&ldquo;Users&rdquo;; &ldquo;dave&rdquo;; &ldquo;test&rdquo;]. We use this in <code>processDirectories</code> to ensure that each part of the path has a corresponding type stemming from the root. This ensures the ZipProvider provides the same hierarchy as a file browser. To be fair I&rsquo;ve reinvented the wheel as this functionality is in <code>Uri.Segments</code>, but this serves as a <em>how-to</em> on extending existing type to bend them to your will! <em>(That&rsquo;s my excuse anyway!)</em></p><pre><code>module Path =
    let getAllDirectories (path:string) =
        let dname = Path.GetDirectoryName path
        dname.Split ([|Path.DirectorySeparatorChar|], StringSplitOptions.RemoveEmptyEntries)
        |&gt; List.ofArray
</code></pre><h3 id=processdirectories>processDirectories</h3><p><code>processDirectories</code> is a recursive function that takes a list of directories and an initial base type and ensures that each directory has been assigned a type and a valid parent. Once the function has processed the entire path the last <code>ProvidedTypeDefintion</code> is returned from the function. You can see this used in <code>buildTypes</code> to either add files or directory properties as explained above. Sometime recursive functions can take a while to click in you brain, the secret here is in the <code>acc</code> or accumulator parameter which is the current parent that&rsquo;s used to add the next type to.</p><pre><code>let directoriesAdded = Dictionary&lt;_,_&gt; ()

let processDirectories directories (root:ProvidedTypeDefinition) =
    let rec loop list (acc:ProvidedTypeDefinition) =
        match list with
        | currentDir :: t -&gt;
            if directoriesAdded.ContainsKey currentDir
            then loop t directoriesAdded.[currentDir]
            else
                //create provided type definition
                let pt = ProvidedTypeDefinition(currentDir, Some(typeof&lt;obj&gt;))
                //add to parent provided type
                acc.AddMember pt
                //add to dictionary
                directoriesAdded.Add (currentDir, pt)
                //recurse
                loop t pt

        | [] -&gt; (*return acc on completion*) acc
    loop directories root
</code></pre><p>There&rsquo;s also <code>safeTypeName</code> shown below, essentially this makes sure the type name is just the last segment of the path and that it doesn&rsquo;t have leading or trailing slashes.</p><pre><code>let safeTypeName name =
    //try get just the filename
    let filename = Path.GetFileName(name)
    //if it's empty then it will be a directory
    if String.IsNullOrEmpty filename
    then name.Trim [|Path.DirectorySeparatorChar|]
    else filename
</code></pre><h2 id=and-another-thing->And Another Thing &mldr;</h2><p>Oh I almost forgot, the type extension and type abbreviation I mentioned above, I used these to make things a little easier:</p><pre><code>type PP = ProvidedProperty

type ProvidedProperty =
    static member MkStatic&lt;'a&gt; (name, getter, ?setter) =
        let pp = PP (name, typeof&lt;'a&gt;, IsStatic = true, GetterCode = getter)
        setter |&gt; Option.iter (fun v -&gt; pp.SetterCode &lt;- v)
        pp
</code></pre><p>I added the <code>MkStatic&lt;'a></code> extension to slim down the code necessary to create a <code>ProvidedProperty</code>, without this the creation of a <code>ProvidedProperty</code> would be a little longer:</p><pre><code>let pp = ProvidedProperty (&quot;name&quot;, typeof&lt;mytype&gt;, IsStatic = true, GetterCode = (fun _ -&gt; Expr.Value 42)) 
</code></pre><p>It&rsquo;s pure laziness, I get sick of typing <code>typeof&lt;'a></code> all the time, and the object initializer property names like <code>GetterCode = ...</code>. The same goes for the type abbreviation. If I find myself typing a lot of repetitive long type names like <code>ProvidedProperty</code> then why not shorten it to PP. I do this when working with quotation types too.</p><p>If you wondering about the namespace I use, <em>Xebec</em>, its part of a suite of things I&rsquo;ve been working on and off for a while involving lots of different things, it just my private codename I use&mldr;</p><h2 id=99-ways-to-die>99 Ways To Die</h2><p>OK here&rsquo;s all the code from top to bottom 99 lines. I don&rsquo;t really like to duplicate but after the explanation about it will probably (hopefully) make sense now to read through.</p><pre><code>namespace Xebex.Zip

open System
open System.Collections
open System.Collections.Generic
open System.IO
open System.Reflection
open System.Collections
open Microsoft.FSharp
open Microsoft.FSharp.Core.CompilerServices
open Microsoft.FSharp.Quotations
open ProviderImplementation.ProvidedTypes
open SharpCompress.Archive

module Path =
    let getAllDirectories (path:string) =
        let dname = Path.GetDirectoryName path
        dname.Split ([|Path.DirectorySeparatorChar|], StringSplitOptions.RemoveEmptyEntries)
        |&gt; List.ofArray

type PP = ProvidedProperty

type ProvidedProperty =
    static member MkStatic&lt;'a&gt; (name, getter, ?setter) =
        let pp = PP (name, typeof&lt;'a&gt;, IsStatic = true, GetterCode = getter)
        setter |&gt; Option.iter (fun v -&gt; pp.SetterCode &lt;- v)
        pp

[&lt;TypeProvider&gt;]
type public ZipProvider(cfg : TypeProviderConfig) as this =
    inherit TypeProviderForNamespaces()

    let asm = Assembly.GetExecutingAssembly()
    let ns = &quot;Xebec&quot;
    let root = ProvidedTypeDefinition(asm, ns, &quot;ZipProvider&quot;, Some(typeof&lt;obj&gt;))
    let filePathParam = ProvidedStaticParameter(&quot;FilePath&quot;, typeof&lt;string&gt;)

    let buildTypes (typeName:string) (args:obj[]) =
        let fileName = args.[0] :?&gt; string
        let zipfile = SharpCompress.Archive.ArchiveFactory.Open(fileName)
        let zipType = ProvidedTypeDefinition(asm, ns, typeName, Some(typeof&lt;obj&gt;))

        let directoriesAdded = Dictionary&lt;_,_&gt; ()

        let processDirectories directories (root:ProvidedTypeDefinition) =
            let rec loop list (acc:ProvidedTypeDefinition) =
                match list with
                | currentDir :: t -&gt;
                    if directoriesAdded.ContainsKey currentDir
                    then loop t directoriesAdded.[currentDir]
                    else
                        //create provided type definition
                        let pt = ProvidedTypeDefinition(currentDir, Some(typeof&lt;obj&gt;))
                        //add to parent provided type
                        acc.AddMember pt
                        //add to dictionary
                        directoriesAdded.Add (currentDir, pt)
                        //recurse
                        loop t pt

                | [] -&gt; (*return acc on completion*) acc
            loop directories root

        let safeTypeName name =
            //try get just the filename
            let filename = Path.GetFileName(name)
            //if it's empty then it will be a directory
            if String.IsNullOrEmpty filename
            then name.Trim [|Path.DirectorySeparatorChar|]
            else filename

        let mkProperties (entry:IArchiveEntry) = 
            [yield PP.MkStatic (&quot;FilePath&quot;, fun _ -&gt; Expr.Value entry.FilePath)
             if not entry.IsDirectory then yield PP.MkStatic (&quot;Crc&quot;, fun _ -&gt; Expr.Value entry.Crc)
             yield PP.MkStatic (&quot;PackedSize&quot;, fun _ -&gt; Expr.Value entry.CompressedSize)
             yield PP.MkStatic (&quot;Size&quot;, fun _ -&gt; Expr.Value entry.Size)
             yield PP.MkStatic (&quot;CompressionRatio&quot;, fun _ -&gt; Expr.Value (float entry.Size / float entry.CompressedSize))
             yield PP.MkStatic (&quot;SpaceSavings&quot;, fun _ -&gt; Expr.Value (1.0 - float entry.CompressedSize / float entry.Size))]

        for entry in zipfile.Entries do

            //we need to add types for each directory before adding the zipEntryType to the last occurrence
            let dirs = Path.getAllDirectories entry.FilePath
            let parent = processDirectories dirs zipType

            if entry.IsDirectory then
                parent.AddMembers &lt;| mkProperties entry
            else
                let zipEntry = ProvidedTypeDefinition(safeTypeName entry.FilePath, Some(typeof&lt;obj&gt;))
                zipEntry.AddMembers &lt;| mkProperties entry
                parent.AddMember(zipEntry)

        zipType

    do root.DefineStaticParameters ([filePathParam], buildTypes)
    do this.AddNamespace(ns, [root])
        
[&lt;TypeProviderAssembly&gt;]
do()
</code></pre><p>So if you made it this far you have seen: Type Providers, recursive functions, list comprehensions, type extensions, type abbreviations, object initialisers, pattern matching, and quotations, quite a few F# features!</p><p>Until next time!</p></div></section><section class="pagination clearfix"><a class="btn previous" href=https://7sharp9.dev/fsharp/2014-06-01-anything-you-can-do/>Anything you can do ...</a>
<a class="btn next" href=https://7sharp9.dev/fsharp/2014-11-17-i-saw-my-reflection-and-cried-dot-dot-dot/>I saw my reflection and cried ...</a></section><section id=disqus_thread class=disqus></section><script>var disqus_config=function(){this.page.url="https://7sharp9.dev/fsharp/2014-11-05-flux-compression-redux/"};(function(){var a=document,b=a.createElement('script');b.src='//7sharp9.disqus.com/embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript></div><footer><div class="footer-info pull-right">© 2021 Dave Thomas</div></footer><script src=https://7sharp9.dev/js/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><script>(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)})(window,document,'script','//www.google-analytics.com/analytics.js','ga'),ga('create','UA-10152365-8','auto'),ga('send','pageview')</script></body></html>