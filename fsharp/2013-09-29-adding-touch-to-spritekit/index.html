<!doctype html><html><head><title>Adding Touch To SpriteKit &#183; 7sharp9</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=generator content="Hugo 0.82.1"><link rel=stylesheet href=https://7sharp9.dev/css/vec.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.ico><link href rel=alternate type=application/rss+xml title=7sharp9></head><body><header><nav><ul><li class=pull-left><a href=https://7sharp9.dev/>/Home</a></li><li class=pull-left><a href=/about>/About</a></li><li class=pull-left><a href=/fsharp>/F#</a></li><li class=pull-left><a href=/running>/Running</a></li><li class=pull-left><a href=/elm>/Elm</a></li><li class=pull-right><a href><i class="fas fa-rss"></i></a></li></ul></nav></header><div class="content wide"><section class=post><h1 class=post-title><a href=https://7sharp9.dev/fsharp/2013-09-29-adding-touch-to-spritekit/>Adding Touch To SpriteKit</a></h1><span class=post-date>Sep 29, 2013</span><div class=post-content><p>Only a quick post this week. Last time we looked at <a href=https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html>SpriteKit</a> and how to add some particle emmiters to simulate a star-field and exhaust on a spaceship, this time lets look at adding some touch based input to move the spaceship around.</p><p>The first thing we need to do is add a type of gesture recogniser, there are various built in <a href=https://developer.apple.com/library/ios/documentation/uikit/reference/UIGestureRecognizer_Class/Reference/Reference.html#//apple_ref/occ/cl/UIGestureRecognizer>gestures</a>:</p><ul><li>UITapGestureRecognizer</li><li>UIPinchGestureRecognizer</li><li>UIRotationGestureRecognizer</li><li>UISwipeGestureRecognizer</li><li>UIPanGestureRecognizer</li><li>UIScreenEdgePanGestureRecognizer</li><li>UILongPressGestureRecognizer</li></ul><p>From the names above it&rsquo;s pretty easy to get a feel for how they should be used, you can create your own subclass of <code>UIGestureRecognizer</code> if you need a custom one.</p><p>Gesture recognizers come in two types continuous and discrete. A discrete gesture is single action like tap or double tap and results in a single action been sent. A continuous gesture is like pan, swipe, or rotate which is interpreted as a series of messages being sent.</p><p>For our purposes we are going to be using the <code>UIPanGestureRecognizer</code> which is a continuous gesture. What we need to do is create a function that sets up the <code>UIPanGestureRecognizer</code> ready for us to use. We do that by creating an instance of the <code>UIPanGestureRecognizer</code> and add it to our view:</p><pre><code>let setupGestures() =
    use panRecogniser = new UIPanGestureRecognizer(x, MonoTouch.ObjCRuntime.Selector(&quot;PanSelector&quot;))
    x.View.AddGestureRecognizer(panRecogniser)
</code></pre><p>Here we are also using a selector, which means we can use an attribute like <code>[&lt;Export("PanSelector")>]</code> to define the function that will be used as the callback. Lets define that function now:</p><pre><code>let OnLabelPan( sender: UIGestureRecognizer) =
    match sender with
    | :? UIPanGestureRecognizer as pan -&gt;
        match pan.State with
        | UIGestureRecognizerState.Changed -&gt;
            let movement = pan.TranslationInView(x.View)
            let move = SKAction.MoveBy(movement.X * 1.75f, -movement.Y * 1.75f, 0.05)
            let ship = scene.GetChildNode(&quot;Ship&quot;)
            ship.RunAction(move)
            pan.SetTranslation(PointF.Empty, x.View)
        | _ -&gt; ()
    | _ -&gt; ()
</code></pre><p>First of all we use pattern matching to do a type match <code>| :? UIPanGestureRecognizer as pan -></code>. This ensures we are dealing with the <code>UIPanGestureRecognizer</code> type. We might of applied multiple gesture recognisers to the view like swipe and rotate and had this function deal with all of them, we can handle this nicely with the type match.</p><p>We can now use a pattern match on the state of the gesture recogniser to react to just the changed event <code>UIGestureRecognizerState.Changed</code>.</p><p>As mentioned previously the pan gesture is continuous and will send a changed action whenever the finger moves on the screen, this gives us a chance to retrieve the current translation of the pan in the current view. We do this by calling <code>pan.TranslationInView(x.View)</code>. We can now apply a movement to our spaceship sprite by creating an action using <code>SKAction.MoveBy</code>. We multiply the translation retrieved by 1.75 to allow for the initial distance the the pan gesture moves before triggering. We also invert the Y axis so that the spaceship sprite moves in the correct Y direction. The final parameter is the time the action runs for, we use a really small time of 0.05 (50ms). This stops the spaceship sprite from moving like an ordinary mouse pointer, just enough inertia to make it feel smooth.</p><p>To apply the action to the spaceship all we need to do is retrieve it from the scene using <code>scene.GetChildNode</code> and call the <code>RunAction</code> function passing in the action we just created.</p><p>Finally we set the pan translation back to zero using: <code>pan.SetTranslation(PointF.Empty, x.View)</code>, this ensures that the spaceship only moves by last changed translation action. Failure to reset the translation would result in the spaceship having too much inertia from the previous actions making it very difficult to control.</p><p>We could also use another overload of <code>UIPanGestureRecognizer</code> which takes an <code>Action&lt;UIPanGestureRecognizer></code>, we can pass this in as a lambda function:</p><pre><code>let setupGestures() =
    use panRecogniser = 
        new UIPanGestureRecognizer
            (fun (pan:UIPanGestureRecognizer) -&gt; 
                match pan.State with
                | UIGestureRecognizerState.Changed -&gt;
                    let movement = pan.TranslationInView(x.View)
                    let move = SKAction.MoveBy(movement.X * 1.75f, -movement.Y * 1.75f, 0.05)
                    let ship = scene.GetChildNode(&quot;Ship&quot;)
                    ship.RunAction(move)
                    pan.SetTranslation(PointF.Empty, x.View)
                | _ -&gt; ())
</code></pre><p>I think the attribute based version is a little cleaner as you can move the callback functionality away from the definition. To be honest I don&rsquo;t mind either way, although if the lambda definition gets too big you will definitely be better off with the former.</p><p>Finally we need to plug in the <code>setupGestures</code> function, we do that by calling it at the end of <code>ViewDidLoad</code>:</p><pre><code>override x.ViewDidLoad () =
    base.ViewDidLoad()
    setupScene()
    setupGestures()
</code></pre><p>Here&rsquo;s a quick YouTube video so you can see this in action:</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe src=https://www.youtube.com/embed/j5JK5zWLdK0 style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="YouTube Video"></iframe></div><p>If you want to check out the project then you can find it in my <a href=https://github.com/7sharp9/SpriteKit-Fsharp-Samples>GitHub repo </a>.</p><p>That&rsquo;s all for now, see you next time!</p></div></section><section class="pagination clearfix"><a class="btn previous" href=https://7sharp9.dev/fsharp/2013-09-20-sprite-kit-particle-fun/>Spritekit particle fun</a>
<a class="btn next" href=https://7sharp9.dev/fsharp/2014-02-10-danger-unstable-structure/>Danger unstable structure - No more!</a></section><section id=disqus_thread class=disqus></section><script>var disqus_config=function(){this.page.url="https://7sharp9.dev/fsharp/2013-09-29-adding-touch-to-spritekit/"};(function(){var a=document,b=a.createElement('script');b.src='//7sharp9.disqus.com/embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript></div><footer><div class="footer-info pull-right">Â© 2021 Dave Thomas</div></footer><script src=https://7sharp9.dev/js/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><script>(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)})(window,document,'script','//www.google-analytics.com/analytics.js','ga'),ga('create','UA-10152365-8','auto'),ga('send','pageview')</script></body></html>