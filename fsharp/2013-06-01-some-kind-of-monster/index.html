<!doctype html><html><head><title>Some kind of monster &#183; 7sharp9</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=generator content="Hugo 0.82.1"><link rel=stylesheet href=https://7sharp9.dev/css/vec.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.ico><link href rel=alternate type=application/rss+xml title=7sharp9></head><body><header><nav><ul><li class=pull-left><a href=https://7sharp9.dev/>/Home</a></li><li class=pull-left><a href=/about>/About</a></li><li class=pull-left><a href=/fsharp>/F#</a></li><li class=pull-left><a href=/running>/Running</a></li><li class=pull-left><a href=/elm>/Elm</a></li><li class=pull-right><a href><i class="fas fa-rss"></i></a></li></ul></nav></header><div class="content wide"><section class=post><h1 class=post-title><a href=https://7sharp9.dev/fsharp/2013-06-01-some-kind-of-monster/>Some kind of monster</a></h1><span class=post-date>Jun 1, 2013</span><div class=post-content><p><figure class="img-left third"><img src=http://upload.wikimedia.org/wikipedia/en/2/29/Godzilla_%2754_design.jpg></figure>What&rsquo;s 100 meters high and weighs in at around 60,000 tons? No its not Godzilla, its Reactive extensions!</p><p>Lately on one of my projects I have been doing a lot of stream manipulation, and although I solved the problem quite easily using F# async workflows, there were other solutions available to help solve the problem. I could of used things like <a href=http://msdn.microsoft.com/en-us/library/vstudio/hh191443.aspx>async await</a>, <a href=http://msdn.microsoft.com/en-us/library/hh228603.aspx>TPL Dataflow(TDF)</a>, and <a href=http://rx.codeplex.com>Reactive Extensions (Rx)</a>. This is going to be a short post on using Rx with F#.</p><h3 id=what-is-rx>What is Rx?</h3><p>Well for those of you that don&rsquo;t know anything about Rx I would suggest reading up a bit of the introduction material <a href=http://rx.codeplex.com>here</a>. Here&rsquo;s a quick recap of what Rx is for everyone else:</p><blockquote><p>The Reactive Extensions (Rx) is a library for composing asynchronous and event-based programs using observable sequences and LINQ-style query operators. Using Rx, developers represent asynchronous data streams with Observables , query asynchronous data streams using LINQ operators , and parameterize the concurrency in the asynchronous data streams using Schedulers . Simply put, Rx = Observables + LINQ + Schedulers.</p></blockquote><h3 id=sample-problem>Sample problem</h3><p>Here&rsquo;s a sample problem: I want to read from a file in buffered chunks and perform an action whenever a chunk is read. As I said before there a many different ways to solve this problem but We&rsquo;ll use C# as a base to see how it could be done first in C#. For this example We&rsquo;ll add an Extension extension method to the <code>Stream</code> class:</p><pre><code>public static class Extensions
{
   public static IObservable&lt;byte[]&gt; ToObservable (this Stream stream, int size)
   {
      return Observable.Create&lt;byte[]&gt; (observer =&gt;
      {
         byte[] buffer = new byte[size];
         var deferedRead = Observable.Defer(() =&gt; stream.ReadAsync (buffer, 0, size).ToObservable());
         return Observable.Repeat(deferedRead)
                          .Select (i =&gt; buffer.Take(i).ToArray ())
                          .Subscribe (data =&gt; { if (data.Length &gt; 0) observer.OnNext (data);
                                                else observer.OnCompleted ();
                                              }, observer.OnError, observer.OnCompleted);
      });
   }
}
</code></pre><p>Using this extension method we can then do something like this:</p><pre><code>var source = new FileStream (@&quot;test.txt&quot;, FileMode.Open, FileAccess.Read);
source.ToObservable (16).Subscribe (_ =&gt; Console.WriteLine(_.Length));
</code></pre><p>This will print to the console the length of each chunk as it is read.</p><p>There are quite a few different Rx operators in this example, <code>Create</code>, <code>Defer</code>, <code>ToObservable</code>, <code>Repeat</code>, <code>Select</code>, and <code>Subscribe</code>. Lets quickly go though the example and see what&rsquo;s going on.</p><p>First of all we create a custom observable sequence using <code>Observable.Create</code>. This takes a lambda function with a single parameter <code>observer</code>, which is of type <code>IObserver&lt;byte[]></code>. Using the <code>observer</code> we can produce elements in the sequence by using the methods <code>OnNext</code>, <code>OnError</code> and <code>OnCompleted</code>.</p><p>Next up we create a buffer to hold the data which will be read from the file in chunks. This is just a simple array allocation <code>byte[] buffer = new byte[size];</code></p><p>To allow us to consume the data from the file stream we can use the <code>ReadAsync</code> method which will return a <code>Task&lt;byte[]></code>. There is an Rx extension method on <code>Task</code> called <code>ToObservable</code> so we use that too. You will notice in the code that we are using <code>Observable.Defer</code>. Why are we using that? What would happen if we didn&rsquo;t? Well, if we don&rsquo;t defer the <code>Task</code> for later execution and simply use to <code>Task.ToObservable()</code> we would be creating a new instance of the <code>Observable</code> sequence each time <code>ReadAsync</code> is called - This would mean we would have an infinite sequence comprised of the first chunk of the file, which isnt waht we want at all. By using <code>Defer</code> we don&rsquo;t invoke the <code>Observable</code> <code>Task</code> until first subscription to the <code>Observable</code> sequence.</p><p>We use a fluent style to repeat the deferred Observable <code>deferedRead</code> using the <code>Repeat</code> method.</p><p><code>Select</code> is now used to take the number of bytes from the <code>buffer</code>, we might have a stream which is not divisible by the buffer size which will mean that the last read will not be the size of the buffer. In the lambda expression the <code>i</code> parameter is the number of the bytes returned from <code>ReadAsync</code>.</p><p>Finally we have <code>Subscribe</code>, this takes a lambda that is passed <code>data</code>, data being the current chunk or <code>byte[]</code>. In the body of the lambda we check to see if we have received any bytes, if so then we call <code>observer.OnNext(data)</code> which creates the next element in the sequence. If we didn&rsquo;t receive data then we call <code>observer.OnCompleted()</code>, which completes the sequence. The last two parameters for <code>Subscribe</code> are the error and completed actions, we simply use the ones in the observer - <code>observer.OnError</code> and <code>observer.OnCompleted</code>.</p><p>If you read through the code again now it probably makes more sense the second time around, there&rsquo;s a lot of functionality squeezed into a small space but by using tried and tested components / functions in Rx you should have a better experience than rolling your own parts, of course you can do the same with <a href=http://msdn.microsoft.com/en-us/library/hh228603.aspx>TDF</a> but I wont go into that here.</p><p>So what would all this look like in F#?</p><p>Well, if you try to do a direct port you start to hit a few issues due to the amount of overloads for some of the methods, <code>Zip</code> for example, has a staggering 19 overloads!! This almost always means your working right at the edge of the ability of <a href=http://stackoverflow.com/a/501356/607275>type inferencing</a>. In order to determine what method overload you intended to use you have to add further type parameters, this can sometimes be a tricky business as F# lambda&rsquo;s are not always correctly typed back to <code>Action</code> and <code>Func</code>.</p><p>Lets see an example of that now:</p><pre><code>module StreamExt =
   type Stream with
      member x.ToObservable(size) =
         Observable.Create(fun (observer: IObserver&lt;_&gt;) -&gt;
            let buffer = Array.zeroCreate size
            let defered = Observable.Defer(fun () -&gt; (x.ReadAsync (buffer, 0, size)).ToObservable())
            Observable.Repeat&lt;int&gt;(defered)
                      .Select(fun i -&gt; buffer.Take(i).ToArray())
                      .Subscribe( (fun (data:byte[]) -&gt; if data.Length &gt; 0 then observer.OnNext(data)
                                                        else observer.OnCompleted()), observer.OnError, observer.OnCompleted ))
</code></pre><p>I had to add quite a few type annotations to get this working. You can end up spending quite a while adding explicit types which isn&rsquo;t exactly an enjoyable or productive way of spending your time, sometimes you can hit a wall and have to annotate the function separately to see where the inference is failing.</p><p>To make things easier you can wrap the overloads with F# friendly versions. In fact this has already been done in the <a href=https://github.com/fsharp/FSharp.Reactive>Fsharp.Reactive</a> repo on GitHub. As I&rsquo;m using Mono I had to do a quick compilation against the Reactive Extensions that come bundled with Mono 3.x rather than the nuget references. I also added in a couple of function&rsquo;s that were missing from this version. Here&rsquo;s the result usin <code>FSharp.Reactive</code>, I think you&rsquo;ll agree it looks a bit better and seems to flow quite nice with the pipeline operators in place.</p><pre><code>module StreamExt =
   type Stream with
      member x.ToObservable(size) =
         Observable.Create (fun (observer: IObserver&lt;_&gt;) -&gt;
            let buffer = Array.zeroCreate size
            Observable.Defer(fun () -&gt; (x.ReadAsync (buffer, 0, size)).ToObservable())
            |&gt; Observable.repeat
            |&gt; Observable.map(fun i -&gt; buffer |&gt; Seq.take i |&gt; Seq.toArray)
            |&gt; Observable.subscribe(function
                                    | data when data.Length &gt; 0 -&gt; observer.OnNext(data)
                                    | _ -&gt; observer.OnCompleted()) observer.OnError observer.OnCompleted)
</code></pre><p>Notable difference are the <code>Observable.Defer</code> is piped into <code>repeat</code>, <code>map</code> and <code>subscribe</code>. Finally, the last piece that&rsquo;s different is the use of the Seq expression <code>(fun i -> buffer |> Seq.take i |> Seq.toArray)</code> rather than the Linq <code>Take</code> function <code>.Select (i => buffer.Take(i).ToArray ())</code>. To be honest there&rsquo;s not really much difference between the two, sequence expressions just seem more natural while using F#. Lastly I switched from the if else expression to a pattern matching using the <a href=http://msdn.microsoft.com/en-us/library/dd233242.aspx>function</a> keyword. It&rsquo;s used in pattern matching when we want to match against only one parameter that&rsquo;s passed into the function. This makes the subscribe function a little more compact.</p><p>Here is the details of the functions that were used in the above snippet so that you don&rsquo;t have to go looking in GitHub for details:</p><pre><code>module Observable =
   ///Repeats the observable
   let repeat f = Observable.Repeat(source = f)

   /// maps the given observable with the given function
   let map f source = Observable.Select(source, Func&lt;_,_&gt;(f))

   /// Subscribes to the observable with all three callbacks
   let subscribe onNext onError onCompleted (observable: 'a IObservable) =
       observable.Subscribe(Observer.Create(Action&lt;_&gt; onNext, Action&lt;_&gt; onError, Action onCompleted))
</code></pre><p>I think that Rx is a very useful library but it&rsquo;s ironic that a functional programming oriented library is not easily usable from a functional language like F#. There are over 400 Observable extension methods if you include all the overloads. Its like ten thousand spoons when all you need is a knife! &mldr; Joking aside I wish the API designers had taken it easy when adding all the extension methods, when you are developing code the last thing you want to do is scroll up and down through method overloads trying to spot which exact overload you are looking for.</p><p>If you want some more samples you might want to take a look at <a href=http://rxwiki.wikidot.com/101samples>101 Rx Samples</a>. Also for reference when building something new, make sure you check out the <a href="http://go.microsoft.com/fwlink/?LinkID=205219">Reactive Extensions design Guide</a>.</p><p>Until next time!</p></div></section><section class="pagination clearfix"><a class="btn previous" href=https://7sharp9.dev/fsharp/2013-05-05-i-node-something/>I node something (Bout You)</a>
<a class="btn next" href=https://7sharp9.dev/fsharp/2013-06-05-monster-zero-revisited/>Monster Zero - Revisited</a></section><section id=disqus_thread class=disqus></section><script>var disqus_config=function(){this.page.url="https://7sharp9.dev/fsharp/2013-06-01-some-kind-of-monster/"};(function(){var a=document,b=a.createElement('script');b.src='//7sharp9.disqus.com/embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript></div><footer><div class="footer-info pull-right">© 2021 Dave Thomas</div></footer><script src=https://7sharp9.dev/js/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><script>(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)})(window,document,'script','//www.google-analytics.com/analytics.js','ga'),ga('create','UA-10152365-8','auto'),ga('send','pageview')</script></body></html>