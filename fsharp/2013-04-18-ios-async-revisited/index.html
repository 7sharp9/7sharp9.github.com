<!doctype html><html><head><title>iOS async revisited &#183; 7sharp9</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=generator content="Hugo 0.82.1"><link rel=stylesheet href=https://7sharp9.dev/css/vec.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.ico><link href rel=alternate type=application/rss+xml title=7sharp9></head><body><header><nav><ul><li class=pull-left><a href=https://7sharp9.dev/>/Home</a></li><li class=pull-left><a href=/about>/About</a></li><li class=pull-left><a href=/fsharp>/F#</a></li><li class=pull-left><a href=/running>/Running</a></li><li class=pull-left><a href=/elm>/Elm</a></li><li class=pull-right><a href><i class="fas fa-rss"></i></a></li></ul></nav></header><div class="content wide"><section class=post><h1 class=post-title><a href=https://7sharp9.dev/fsharp/2013-04-18-ios-async-revisited/>iOS async revisited</a></h1><span class=post-date>Apr 18, 2013</span><div class=post-content><p>In this post weare going to look as async again, but from the perspective of F#.</p><h3 id=xamarin-evolve-2013>Xamarin Evolve 2013</h3><p><figure><img src=http://blog.xamarin.com/wp-content/uploads/2013/04/Screen-Shot-2013-04-03-at-11.07.21-AM.png></figure><br>I have been watching the Xamarin Evolve conference this week and it was good to see Miguel announce full support for F#. Those that follow me on twitter etc, will know that I have been doing F# for quite a while in MonoDevelop and Xamarin Studio. The new support currently entails some new project templates so that you can easily create epic new F# Apps without having to refer to my blog. While its sad that my content now falls into the archives its nice to get official support announced in such a grand fashion.</p><h3 id=f-async>F# Async</h3><p>Kudos to Miguel for covering some history of C#&rsquo;s async feature right back down to its F# heritage too, which appeared in 2007, thanks to the work of Don Syme and the F# team. You can read more about that on <a href=http://blogs.msdn.com/b/dsyme/archive/2013/03/24/asynchronous-programming-from-f-to-python.aspx>Don Syme&rsquo;s blog</a> or have a look at the research paper <a href="http://research.microsoft.com/apps/pubs/default.aspx?id=147194">here</a>.</p><p>So the highly anticipated async await model in C# that&rsquo;s just gone beta in Xamarin addin channel? We&rsquo;ve had it for ages in F#! In fact, I suspect you will have been able to use it for quite some time, even before I started hacking together support for F# in iOS! Anyway, that&rsquo;s enough of the smugness :-) lets get on and see what it looks like using some of the code from the previous post as a reference.</p><p>Ill include the C# version first so that you can see the difference rather than having to open my last post.</p><pre><code>// Asynchronous HTTP request
public async void HttpSample ()
{
    Application.Busy ();
    var request = WebRequest.Create (Application.WisdomUrl);

    //async await version
    try{
        var response = await request.GetResponseAsync();
        Application.Done ();
        ad.RenderRssStream(response.GetResponseStream());
    } catch {
        // Error
    }
}
</code></pre><p>One of the advantages of the F# Async model is it&rsquo;s composable nature and controllability. The key to F# async is that its defined with F#&rsquo;s <a href=http://msdn.microsoft.com/en-gb/library/dd233182.aspx>computation expression</a> syntax:</p><blockquote><p>Computation expressions in F# provide a convenient syntax for writing computations that can be sequenced and combined using control flow constructs and bindings.</p></blockquote><p>There are several built in workflows: <a href=http://msdn.microsoft.com/en-gb/library/dd233209.aspx>Sequences</a>, <a href=http://msdn.microsoft.com/en-gb/library/dd233250.aspx>Asynchronous Workflows</a>, and <a href=http://msdn.microsoft.com/en-gb/library/hh225374.aspx>Query Expressions</a>. Whenever you use a computation expression it is as follows:- <code>builder-name { expression }</code>. With that tiny bit of background, lets look at the corresponding F# async code:</p><pre><code>member x.HttpSample() =
    Application.Busy() 
    let request = WebRequest.Create(Application.WisdomUrl )
    
    //F# async version
    async {try let! response = request.AsyncGetResponse()
               Application.Done()
               ad(response.GetResponseStream())
           with ex -&gt; () } |&gt; Async.Start
</code></pre><p>You can see there is quite a similarity between this snippet and the C# one and you should be able to figure out what&rsquo;s happening given the knowledge from the previous post.</p><p>One of the first things you will notice the builder - <code>async { ...</code>, followed by the <code>let!</code> statement. You can think of the <code>let!</code> as the C# equivalent of await. <code>let!</code> starts the computation <code>request.AsyncGetResponse()</code>, and then the thread is suspended until the result is available, at this point execution continues to the next statment, which in this case is <code>Application.Done()</code>.</p><p>Those of you comparing the difference will notice that in the C# version after <code>Application.Done();</code> we call <code>ad.RenderRssStream(response.GetResponseStream())</code> but in the F# version we simply call <code>ad(response.GetResponseStream())</code>. If we take a quick look at the constructors for the types that hold these methods I can show you the difference a bit better:</p><p>The C# version looks like this:</p><pre><code>public class DotNet 
{
	AppDelegate ad;

	public DotNet (AppDelegate ad)
	{
		this.ad = ad;
	}
}
</code></pre><p>The F# one I can show on a single line:</p><pre><code>type DotNet(ad: Stream -&gt; unit) =
</code></pre><p>The main difference is that The C# version has the entire <code>AppDelegate</code> class is passed in, whereas the F# version just takes a function with the signature <code>Stream -> unit</code>. In fact the F# version doesn&rsquo;t even need to be placed inside a type like the C# version, we can use a <a href=http://msdn.microsoft.com/en-gb/library/dd233221.aspx>module</a>, again Ill quote from MSDN:</p><blockquote><p>In the context of the F# language, a module is a grouping of F# code, such as values, types, and function values, in an F# program. Grouping code in modules helps keep related code together and helps avoid name conflicts in your program.</p></blockquote><h3 id=f-modules>F# Modules</h3><pre><code>module DotNet' =
    let HttpSample(ad) =
            Application.Busy() 
            let request = WebRequest.Create(Application.WisdomUrl )
            
            //F# async version
            async {try let! response = request.AsyncGetResponse()
                       Application.Done()
                       ad(response.GetResponseStream())
                   with ex -&gt; () } |&gt; Async.Start
</code></pre><p>When we want to call this code we can open the module like you would a namespace:</p><pre><code>open DotNet
HttpSample(ad)
</code></pre><p>Or access it fully qualified by including the <code>module</code> name:</p><pre><code>DotNet.HttpSample(ad)
</code></pre><p>How would this code look from the context of this sample application?</p><p>Here is a snipped from the AppDelegate code which makes use of this module</p><pre><code>// This method is invoked when the application has loaded its UI and its ready to run
override x.FinishedLaunching (app:UIApplication, options:NSDictionary) =
    x.window.AddSubview (x.navigationController.View)
    x.button1.TouchDown.Add 
        (fun _ -&gt;  if not UIApplication.SharedApplication.NetworkActivityIndicatorVisible then           
                       match x.stack.SelectedRow() with
                       | 0 -&gt; DotNet.HttpSample x.RenderRssStream
                       | 1 -&gt; DotNet.HttpSecureSample x.RenderStream
                       | _ -&gt; (new Cocoa(x.RenderRssStream)).HttpSample() |&gt; ignore )    
    TableViewSelector.Configure (x.stack, [|&quot;http  - WebRequest&quot;
                                            &quot;https - WebRequest&quot;
                                            &quot;http  - NSUrlConnection&quot; |] )                    
    x.window.MakeKeyAndVisible()
    true
</code></pre><p>There are a few departures from the C# sample code which Ill include below now:</p><pre><code>// This method is invoked when the application has loaded its UI and its ready to run
public override bool FinishedLaunching (UIApplication app, NSDictionary options)
{
  window.AddSubview (navigationController.View);

  button1.TouchDown += Button1TouchDown;
  TableViewSelector.Configure (this.stack, new string [] {
    &quot;http  - WebRequest&quot;,
    &quot;https - WebRequest&quot;,
    &quot;http  - NSUrlConnection&quot;
  });

  window.MakeKeyAndVisible ();

  return true;
}

void Button1TouchDown (object sender, EventArgs e)
{
  // Do not queue more than one request
  if (UIApplication.SharedApplication.NetworkActivityIndicatorVisible)
    return;

  switch (stack.SelectedRow ()){
  case 0:
    new DotNet (this).HttpSample ();
    break;

  case 1:
    new DotNet (this).HttpSecureSample ();
    break;

  case 2:
    new Cocoa (this).HttpSample ();
    break;
  }
}
</code></pre><p>Firstly we are using an lambda expression for the event handler via the Add method rather than the += handler which we use in C#. We are also using F#&rsquo;s awesome <a href=http://msdn.microsoft.com/en-gb/library/dd547125.aspx>pattern matching</a> feature on the results of <code>x.stack.SelectedRow()</code>. This allows you to encode complex logic and also have the compiler assist you by catching non covered cases.</p><p>I&rsquo;m going to leave it there for now as I don&rsquo;t want to bombard any newcomers with tons of new F# features, and I also don&rsquo;t want to teach any of my regular F# followers how to suck eggs. If anyone has a preference for more in depth comparisons to the C# version then let me know then I can tailor that into further posts on the subject.</p><p>Until next time!</p></div></section><section class="pagination clearfix"><a class="btn previous" href=https://7sharp9.dev/fsharp/2013-04-16-a-little-bit-of-ios-async/>A little bit of iOS async</a>
<a class="btn next" href=https://7sharp9.dev/fsharp/2013-05-05-i-node-something/>I node something (Bout You)</a></section><section id=disqus_thread class=disqus></section><script>var disqus_config=function(){this.page.url="https://7sharp9.dev/fsharp/2013-04-18-ios-async-revisited/"};(function(){var a=document,b=a.createElement('script');b.src='//7sharp9.disqus.com/embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript></div><footer><div class="footer-info pull-right">© 2021 Dave Thomas</div></footer><script src=https://7sharp9.dev/js/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><script>(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)})(window,document,'script','//www.google-analytics.com/analytics.js','ga'),ga('create','UA-10152365-8','auto'),ga('send','pageview')</script></body></html>