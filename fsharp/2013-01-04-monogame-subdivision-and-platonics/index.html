<!doctype html><html><head><title>MonoGame subdivision and platonics &#183; 7sharp9</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=generator content="Hugo 0.82.1"><link rel=stylesheet href=https://7sharp9.dev/css/vec.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.ico><link href rel=alternate type=application/rss+xml title=7sharp9></head><body><header><nav><ul><li class=pull-left><a href=https://7sharp9.dev/>/Home</a></li><li class=pull-left><a href=/about>/About</a></li><li class=pull-left><a href=/fsharp>/F#</a></li><li class=pull-left><a href=/running>/Running</a></li><li class=pull-left><a href=/elm>/Elm</a></li><li class=pull-right><a href><i class="fas fa-rss"></i></a></li></ul></nav></header><div class="content wide"><section class=post><h1 class=post-title><a href=https://7sharp9.dev/fsharp/2013-01-04-monogame-subdivision-and-platonics/>MonoGame subdivision and platonics</a></h1><span class=post-date>Jan 4, 2013</span><div class=post-content><p>I&rsquo;ve been on a bit of a break from my normal jovial self due to a shit storm of bad stuff happening that I wont go into here, but hopefully this years going to be awesome. Anyway, here&rsquo;s the next exciting installment in my series on MonoGame. <em>(Well I find it exciting anyway :-) )</em></p><p>If you remember back to the <a href=https://github.com/7sharp9/PlatonicSolids>last post</a> I mentioned the <a href=http://en.wikipedia.org/wiki/Platonic_solid>platonic solids</a>, and we created and rendered the tetrahedron, lets recap on what the five solids are:</p><ol><li>Tetrahedron (four faces)</li><li>Cube or hexahedron (six faces)</li><li>Octahedron (eight faces)</li><li>Dodecahedron (twelve faces)</li><li>Icosahedron (twenty faces)</li></ol><p>We covered the tetrahedron in the <a href=https://github.com/7sharp9/PlatonicSolids>previous post</a> and the hexahedron is pretty humdrum so I&rsquo;m not going to cover that here so lets move onto the next one the octahedron.</p><h2 id=creating-the-octahedron>Creating the Octahedron</h2><p>Here&rsquo;s a function that we will use to generate an octahedron:</p><pre><code>module Platonic
  let createOctahedron()=    
      let top = Vector3.Up
      let midOne =   top |&gt; Vector3.transform (Matrix.CreateRotationX(toRad 90.0f) * Matrix.CreateRotationY(toRad 45.f))
      let midTwo =   top |&gt; Vector3.transform (Matrix.CreateRotationX(toRad 90.0f) * Matrix.CreateRotationY(toRad 135.f))
      let midThree = top |&gt; Vector3.transform (Matrix.CreateRotationX(toRad 90.0f) * Matrix.CreateRotationY(toRad 225.f))
      let midFour =  top |&gt; Vector3.transform (Matrix.CreateRotationX(toRad 90.0f) * Matrix.CreateRotationY(toRad 315.f))
      let bottom =   top |&gt; Vector3.transform (Matrix.CreateRotationX(toRad 180.f))
      
      [| midOne; top;  midTwo
         midTwo; top; midThree
         midThree; top; midFour
         midFour;  top; midOne 
         midOne; midTwo; bottom
         midTwo; midThree; bottom
         midThree; midFour; bottom
         midFour; midOne; bottom |]
</code></pre><p>You can see that the bulk of the code is centred around rotating a Y axis <a href=http://en.wikipedia.org/wiki/Unit_vector>unit vector</a> <code>top</code> around the X and Y axis. All the vertices around the centre od the octahedron lie on the same plain and are simply rotated by 90 degrees in the X axis and then rotated by multiples of 90 degrees in the Y axis starting at 45 degrees (45, 135, 225, 315). Finally the the <code>top</code> unit vector is flipped to the bottom by rotating around 180 degrees in the X axis, this forms the bottom point. The final step consists of combining the vertices into an array with the array syntax <code>[| ... |]</code> specifing each triangle of the octahedron in turn.</p><p>If you were looking carefully you might have noticed that the <code>Vector3.transform</code> function is not part of the MonoGame library. I wrapped MonoGames&rsquo;s <code>Vector3.Transform</code> function so that the <code>Vector3</code> is the last parameter so we can use the forward pipeline operator <code>|></code>:</p><pre><code>module Vector3 =
    let transform (m:Matrix) v = 
        Vector3.Transform(v, m)
</code></pre><h2 id=drawing-the-octahedron>Drawing the Octahedron</h2><p>What now? Well, with this code we have just been working with the raw vertices, we now need to get this into a form that <a href=http://www.monogame.net>MonoGame</a> can render, namely an array of the <code>VertexPositionColor</code> structure. It&rsquo;s a bit of a mouthful so lets alias this so we can simply refer to it as <code>vpc</code>:</p><pre><code>let vpc v c = VertexPositionColor(v, c)
</code></pre><p>To render the octahedron we can now modify the draw method of the tetrahedron code from the <a href=https://github.com/7sharp9/PlatonicSolids>last post</a> maybe something like this should illustrate:</p><pre><code>override x.Draw (gameTime) =
  // Clear the backbuffer
  x.GraphicsDevice.Clear (Color.CornflowerBlue)
  for pass in basicEffect.CurrentTechnique.Passes do
      pass.Apply()
      let octahedron = 
          Platonic.createOctahedron() 
          |&gt; Array.mapi (fun i -&gt; Platonic.vpc (if i % 2 = 0 then Color.BlueViolet
                                                else Color.Orange) )
      x.GraphicsDevice.DrawUserPrimitives(PrimitiveType.TriangleList, octahedron, 0, octahedron.Length / 3)
</code></pre><p>Bear in mind we are not looking at optimisation at all at this stage purely visualising what we have. We are using the <code>mapi</code> function to alternate between defining blue violet and orange vertex colours. At the moment because we haven&rsquo;t set up any lights the octahedron would just appear as diamond chunk of colour with no shading, with these two simple vertex colours we can see the separate facets and see the 3D form.</p><figure><img src=/img/octahedron.jpg></figure><h2 id=subdivision-surfaces>Subdivision Surfaces</h2><p>According to <a href=http://en.wikipedia.org/wiki/Subdivision_surface>Wikipedia</a>:</p><blockquote><p>A subdivision surface, in the field of 3D computer graphics, is a method of representing a smooth surface via the specification of a coarser piecewise linear polygon mesh. The smooth surface can be calculated from the coarse mesh as the limit of a recursive process of subdividing each polygonal face into smaller faces that better approximate the smooth surface.</p></blockquote><p>They are also known as scalable geometry. I&rsquo;m not going to get into the realm of true sub-divisional modelling such as providing a visible control surface with editing and crease support, I just wouldn&rsquo;t be able to do it justice within the scope of this introductory series. Applications like <a href="http://usa.autodesk.com/adsk/servlet/pc/index?id=13571168&siteID=123112">Softimage</a> or <a href=http://usa.autodesk.com/maya/>Maya</a> are masters of sub-divisional modelling, you might want to check those out if you are interested in what can be done in that area. Subdivision surfaces have been quite popular in the computer graphics industry as it allows modellers and animators to work with simple mesh surfaces with far less control points that can be rendered with super smooth detail but without the constraints of having to work with millions of points on the screen at once which can be computationally very expensive and distracting. Nowadays that kind of processing is done by a <a href=http://en.wikipedia.org/wiki/Graphics_processing_unit>GPU&rsquo;s</a> <a href=http://en.wikipedia.org/wiki/Shader#Vertex_shaders>vertex shader&rsquo;s</a> or more recently the <a href=http://en.wikipedia.org/wiki/Shader#Geometry_shaders>geometry shader&rsquo;s</a> which can take a simple triangle as an input and produce zero or more triangles as its output.</p><p>One of the properties of platonic solids is that all of the defining vertices lie on a sphere. If we were to take each of the defining faces or triangles and recursively divide them into four smaller triangles, and project each of the containing vertices onto the sphere then eventually we would get an approximation of a sphere. This was the basis of Charles Loop&rsquo;s thesis <a href=http://research.microsoft.com/~cloop/thesis.pdf>Smooth Subdivision Surfaces Based on Triangles</a>. What I am going to present here will not go into that level of detail and we will not be generating any control surfaces to act on the subdivision mesh. We could call this a poor man&rsquo;s subdivision surface or sphere approximation :-).</p><p>Lets create a quick and dirty function to try this out anyway:</p><pre><code>let rec subdivide(v1, v2, v3, depth) =
  seq{match depth with
      | 0 -&gt; yield vpc Color.LightBlue (v1 |&gt; Vector3.Normalize) 
             yield vpc Color.AliceBlue (v2 |&gt; Vector3.Normalize) 
             yield vpc Color.SlateGray (v3 |&gt; Vector3.Normalize) 
             
      | _ -&gt; let u12 = ((v1 + v2) / 2.0f) |&gt; Vector3.Normalize
             let u23 = ((v2 + v3) / 2.0f) |&gt; Vector3.Normalize
             let u31 = ((v3 + v1) / 2.0f) |&gt; Vector3.Normalize

             yield! subdivide(v1, u12, u31, depth-1)
             yield! subdivide(v2, u23, u12, depth-1)
             yield! subdivide(v3, u31, u23, depth-1)
             yield! subdivide(u12, u23, u31, depth-1) }
</code></pre><p>Here we have a recursive function that takes three vertices <code>v1, v2, v3</code> and a depth parameter. When the depth parameter is zero we are at our subdivision maximum and we return a normalized triangle. Incidentally for the same lighting issues mentioned above we use three different colours for the vertices: light blue, alice blue, and slate grey. The three vertices <code>u12, u23, u31</code> define the points in-between the input triangle, we calculate them by adding the vertices together and dividing them by two <code>((v1 + v2) / 2.0f)</code> then pipe-lining the result to the normalize function (<code>|> Vector3.Normalize</code>). We do this for each of the points. The final step is the <code>yield!</code> section which creates the next level of subdivision for each of the resulting four triangles. Remember our input triangle is divided into four. If fact in the previous article there are several images of this:</p><p><figure class=third><img src=https://lh4.googleusercontent.com/-NpV1nz3K-kI/ULKY-KY6emI/AAAAAAAABio/565nXCNC9xY/s425/texture+coords.png alt=Tetrahedron-coordinates><figcaption><p>Tetrahedron-coordinates</p></figcaption></figure><figure class=third><img src=https://lh4.googleusercontent.com/-hLyy6qGXjWc/ULKn_4p-CUI/AAAAAAAABjA/azvh8cUNrAY/s310/Tetrahedron.png alt=Tetrahedron><figcaption><p>Tetrahedron</p></figcaption></figure></p><p>The <a href=http://en.wikipedia.org/wiki/Sierpinski_triangle>Sierpinski triangle</a> (<em>without the holes</em>) is actually our subdivision method, except the we subdivide every triangle produced.</p><p>To try this out lets change the <code>Draw</code> method so that it looks like this:</p><pre><code>override x.Draw (gameTime) =
    x.GraphicsDevice.Clear (Color.CornflowerBlue)
    for pass in basicEffect.CurrentTechnique.Passes do
        pass.Apply()
        let subdiv = Platonic.createOctahedron() 
                     |&gt; Seq.windowed 3
                     |&gt; Seq.map (function 
                                 | [|a;b;c|] -&gt; subdivide(a,b,c, 3)         
                                 | _ -&gt; failwith &quot;Unsupported array size.&quot; )                 
                     |&gt; Seq.concat 
                     |&gt; Seq.toArray                                                                         
        x.GraphicsDevice.DrawUserPrimitives(PrimitiveType.TriangleList, subdiv, 0, subdiv.Length / 3)
</code></pre><p>Here we are using some of the functions from the sequence module to group and process the vertices.</p><ul><li>First the result of <code>Platonic.createOctahedron()</code> is grouped into triangles using <code>Seq.windowed 3</code>.</li><li>Now we map each the triangle using the using the <code>subdivide</code> function.</li><li>Next we merge the sequence back together using <code>Seq.concat</code>.</li><li>Finally we convert the sequence back into an array with <code>Seq.toArray</code>.</li></ul><p>The image below shows the octahedron at various levels of subdivision from one through to four:<figure><img src=/img/subdivisions.png></figure></p><p>Well I hope you enjoyed this brief sojourn into subdivision, if you want to investigate further I recommend looking at the following papers.</p><p><a href=http://www.cs.berkeley.edu/~sequin/CS284/PAPERS/CatmullClark_SDSurf.pdf>Recursively generated B-spline surfaces on arbitrary topological meshes</a><br><a href=http://research.microsoft.com/~cloop/thesis.pdf>Smooth Subdivision Surfaces Based on Triangles</a><br><a href=http://www.dgp.toronto.edu/people/stam/reality/Research/pdf/loop.pdf>Evaluation of Loop Subdivision Surfaces</a></p><p>It&rsquo;s a very interesting area and I dont think will be able to resist doing another article delving deaper later on.</p><p>Until next time&mldr;</p></div></section><section class="pagination clearfix"><a class="btn previous" href=https://7sharp9.dev/fsharp/2012-11-25-monogame-3d-basics/>MonoGame 3D basics</a>
<a class="btn next" href=https://7sharp9.dev/fsharp/2013-02-03-monotouch-and-fsharp-part-i/>MonoTouch and F# part I</a></section><section id=disqus_thread class=disqus></section><script>var disqus_config=function(){this.page.url="https://7sharp9.dev/fsharp/2013-01-04-monogame-subdivision-and-platonics/"};(function(){var a=document,b=a.createElement('script');b.src='//7sharp9.disqus.com/embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript></div><footer><div class="footer-info pull-right">© 2021 Dave Thomas</div></footer><script src=https://7sharp9.dev/js/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><script>(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)})(window,document,'script','//www.google-analytics.com/analytics.js','ga'),ga('create','UA-10152365-8','auto'),ga('send','pageview')</script></body></html>