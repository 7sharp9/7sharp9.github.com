<!doctype html><html><head><title>MonoGame 3D basics &#183; 7sharp9</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=generator content="Hugo 0.82.1"><link rel=stylesheet href=https://7sharp9.dev/css/vec.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.ico><link href rel=alternate type=application/rss+xml title=7sharp9></head><body><header><nav><ul><li class=pull-left><a href=https://7sharp9.dev/>/Home</a></li><li class=pull-left><a href=/about>/About</a></li><li class=pull-left><a href=/fsharp>/F#</a></li><li class=pull-left><a href=/running>/Running</a></li><li class=pull-left><a href=/elm>/Elm</a></li><li class=pull-right><a href><i class="fas fa-rss"></i></a></li></ul></nav></header><div class="content wide"><section class=post><h1 class=post-title><a href=https://7sharp9.dev/fsharp/2012-11-25-monogame-3d-basics/>MonoGame 3D basics</a></h1><span class=post-date>Nov 25, 2012</span><div class=post-content><p>This time we are going to get into a little bit of code and produce the simplest of all 3d solids, the
tetrahedron. I know its not the most exciting of things but we have to start somewhere. The scope of 3D
graphics in computers is so vast that its very easy to get lost in the vast piles of research papers.</p><p>First lets do some basic setup, if you followed my last post then you will will have a project template to use, this
makes this a little easier.</p><p><strong>For those of you that are running on Windows and want to use Visual Studio please leave a comment if you would like
a project template for F#</strong>. The beauty of MonoGame is that it is cross platform and there is only a small amount of code
that differers between the different platforms, and that is localised to the main entry point rather than the <code>Game</code> type.</p><p>First create a new <code>MonoGame Mac Application project</code>, you should end up with a Game1 type that looks like this:</p><pre><code>type MonoGame3DBasics() as x =
    inherit Game()
    let graphics = new GraphicsDeviceManager(x)
    let mutable spriteBatch = Unchecked.defaultof&lt;_&gt;
    let mutable logoTexture = Unchecked.defaultof&lt;_&gt;
    do x.Content.RootDirectory &lt;- &quot;Content&quot;
       graphics.IsFullScreen &lt;- false
 
    /// Overridden from the base Game.Initialize. Once the GraphicsDevice is setup,
    /// we'll use the viewport to initialize some values.
    override x.Initialize() = base.Initialize()

    /// Load your graphics content.
    override x.LoadContent() =
        // Create a new SpriteBatch, which can be use to draw textures.
        spriteBatch &lt;- new SpriteBatch (graphics.GraphicsDevice)
        
        // TODO: use this.Content to load your game content here eg.
        logoTexture &lt;- x.Content.Load&lt;_&gt;(&quot;logo&quot;)

    /// Allows the game to run logic such as updating the world,
    /// checking for collisions, gathering input, and playing audio.
    override x.Update ( gameTime:GameTime) =
        // TODO: Add your update logic here                 
        base.Update (gameTime)

    /// This is called when the game should draw itself. 
    override x.Draw (gameTime:GameTime) =
        // Clear the backbuffer
        graphics.GraphicsDevice.Clear (Color.CornflowerBlue)

        spriteBatch.Begin()

        // draw the logo
        spriteBatch.Draw (logoTexture, Vector2 (130.f, 200.f), Color.White);
        spriteBatch.End()

        //TODO: Add your drawing code here
        base.Draw (gameTime)
</code></pre><p>We are going to need a few extra field for this sample and we wont be using and 2d so remove the <code>spriteBatch</code> and the
<code>logoTexture</code> as we wont be needing those. The following fields need to be added in their place:</p><pre><code>let mutable basicEffect = Unchecked.defaultof&lt;_&gt;
let mutable texture = Unchecked.defaultof&lt;_&gt;
let mutable vertexBuffer = Unchecked.defaultof&lt;_&gt;
let mutable view = Unchecked.defaultof&lt;_&gt;
let mutable world = Unchecked.defaultof&lt;_&gt;
let mutable projection = Unchecked.defaultof&lt;_&gt;
</code></pre><p>What&rsquo;s this! <strong>mutable</strong> fields! I know, but this simplifies things until I can put together a friendly functional
scaffolding around <a href=http://www.monogame.net>MonoGame</a>. We are creating a <code>basicEffect</code>, this is used to draw the 3D objects, its actually
just a basic shader implementation with simple lighting. We also have <code>texture</code> which will be used as our texture
map. We have a <code>vertexBuffer</code> which is used to store the vertices for out primitive. <code>view</code>, <code>world</code>, and <code>projection</code>
are our matrices which are used to look into our 3D scene. For more information on the theory behind 3D projection have
a look <a href=http://en.wikipedia.org/wiki/3D_projection>here</a>.</p><p>Lets more to the <code>LoadContent</code> override:</p><pre><code>override x.LoadContent() =
    //load texture
    texture &lt;- x.Content.Load&lt;Texture2D&gt;(&quot;Tetrahedron&quot;)
    
    //world, view, projection
    world &lt;- Matrix.Identity
    view &lt;- Matrix.CreateLookAt(Vector3(0.f, 0.f, 10.f), Vector3.Zero, Vector3.Up)
    projection &lt;- Matrix.CreatePerspectiveFieldOfView(MathHelper.PiOver4,
                                                      x.GraphicsDevice.Viewport.AspectRatio,
                                                      1.f,
                                                      1000.f)
        
    basicEffect &lt;- new BasicEffect(x.GraphicsDevice,
                                   World = world,
                                   View = view,
                                   Projection = projection,
                                   Texture = texture,
                                   TextureEnabled = true)
                                     
    let tetrahedronData = generateTetrahedron 3.5f
    vertexBuffer &lt;- new VertexBuffer(x.GraphicsDevice, 
                                     VertexPositionTexture.VertexDeclaration, 
                                     tetrahedronData.Length, 
                                     BufferUsage.WriteOnly)
    vertexBuffer.SetData(tetrahedronData)
    x.GraphicsDevice.SetVertexBuffer(vertexBuffer)
</code></pre><p>The first thing that we do is load the texture map:<br><code>texture &lt;- x.Content.Load&lt;Texture2D>("Tetrahedron")</code><br>This simply loads in the texture named <code>Tetrahedron</code> using the content loader.</p><p>Next we set up the default values for the world matrix, view and projection matrices. The <code>world</code> is simply initialised using
<code>Matrix.Identity</code> which is a matrix defined as:</p><pre><code>[1,0,0,0]
[0,1,0,0]
[0,0,1,0]
[0,0,0,1]
</code></pre><p>The <code>view</code> is initialised using the <code>CreateLookAt</code> method of the Matrix type. This sets up a transformation that points from
0,0,10 to the centre of the world using <code>Vector3.Zero</code>. It also uses the <code>Vector3.Up</code> as the orientation direction <em>(Positive Y is up)</em>.</p><p>The <code>projection</code> is also initialised using the helper method <code>CreatePerspectiveFieldOfView</code> which as you might guess, creates
a perspective with a field of view. In this instance our field of view uses the constant <code>PiOver4</code>.</p><p>The basic effect is now initialised with the matrices we just initialised.</p><p>For now I want you to ignore the line <code>let tetrahedronData = generateTetrahedron 3.5f</code>. I need to explain how to generate a
tetrahedron before that will make sense, just assume that is returns the vertices that we need for the tetrahedron.</p><p>The <code>vertexBuffer</code> is now created which will hold all the vertices for the tetrahedron. We need to tell the <code>vertexBuufer</code>
what format we want to use to hold the vertices, here, we are going to use vertices with Position, Colour, and Texture
coordinates so we we use the predefined format of <code>VertexPositionTexture.VertexDeclaration</code>. There are various different
predefined formats and its also possible to create custom user defined formats, for more information have a look
<a href=http://devblog.phillipspiess.com/2010/03/21/xnas-vertex-structs-and-custom-vertex-formats/>here</a>. I realise I&rsquo;m glossing over a lot of information, this is because the field of 3D graphics is huge even an API
such as XNA/MonoGame which tries to simplify things, there is still a vast array of different concepts and I don&rsquo;t want to
get too bogged down with all the specifics.</p><p>Finally the <code>vertexBuffer</code> is assigned to the graphics device: <code>x.GraphicsDevice.SetVertexBuffer(vertexBuffer)</code>, this
loads the vertex buffer into the graphics card ready to be draw later.</p><p>Next we move on to the <code>Update</code> override:</p><pre><code>        override x.Update(gameTime) = 
            if Keyboard.GetState().IsKeyDown(Keys.Escape) then x.Exit()
            
            let time = float32 gameTime.ElapsedGameTime.TotalSeconds

            // Compute camera matrices.
            let rotationz = Matrix.CreateRotationY(time * 1.2f)
            basicEffect.View &lt;- rotationz * Matrix.CreateLookAt(Vector3(0.f, 0.f, 10.f), Vector3.Zero, Vector3.Up)
                    
            base.Update (gameTime)
</code></pre><p>The <a href=http://msdn.microsoft.com/en-us/library/microsoft.xna.framework.game.update.aspx><code>Update</code></a> method is called every time the game decides that game logic needs to be processed. This includes the
management of game state, the processing of user input, and also the updating of simulation data or AI.</p><p>First of all we check the Escape key has been pressed so that the application can exit: <code>if Keyboard.GetState().IsKeyDown(Keys.Escape) then x.Exit()</code>.</p><p>Next we capture the amount of elapsed time since the last update so that we can calculate distance moved over time etc.</p><p>To make our view of the world less static we create a rotation around the z axis of the world so that we see the tetrahedron
from different angles. We multiply the rotation matrix by our initial <code>Matrix.CreateLookAt...</code> that we used earlier on, and
assign it back to the <code>View</code> property of the <code>basicEffect</code>. I want to stress that the aim of this is not super optimal code
it&rsquo;s merely to show the easiest possible method of achieving a result. In a future post we will be looking at some functional
scaffolding to allow us to apply functional thinking to this domain. Perhaps introducing a small <a href=http://en.wikipedia.org/wiki/Domain-specific_language>Domain Specific Languagee</a> to help.</p><p>Finally we have the <code>Draw</code> override:</p><pre><code>        /// This is called when the game should draw itself. 
        override x.Draw (gameTime) =
            // Clear the backbuffer
            x.GraphicsDevice.Clear (Color.CornflowerBlue)

            for pass in basicEffect.CurrentTechnique.Passes do
                pass.Apply()
                x.GraphicsDevice.DrawPrimitives(PrimitiveType.TriangleList, 0, 4)
                 
            base.Draw (gameTime)
</code></pre><p>The <a href=http://msdn.microsoft.com/en-us/library/microsoft.xna.framework.game.draw.aspx><code>Draw</code></a> override is called every time the game needs to draw a frame, we put all out rendering code in here.</p><p>The first step is to clear the screen to a nice blue colour:</p><p><code>x.GraphicsDevice.Clear (Color.CornflowerBlue)</code></p><p>To draw our tetrahedron we need to loop through the different techniques in out shader (In this instance our basicEffect only has 1), apply the technique, then draw out triangles. You might remember earlier to created a the <code>vertexBuffer</code> and assigned it to the graphics device. All we have to do is tell MonoGame that we want to draw 4 triangles and they are in a <code>TriangleList</code>.</p><p>That&rsquo;s it all done! Well almost, now lets backtrack slightly and look at how we build the vertices for that tetrahedron.</p><h2 id=building-a-tetrahedron>Building a tetrahedron</h2><p>What is a tetrahedron? Well if you look on <a href=http://en.wikipedia.org/wiki/Tetrahedron>wikipedia</a></p><blockquote><p>A tetrahedron is a polyhedron composed of four triangular faces, three of which meet at each vertex. It has six edges and four vertices. The tetrahedron is the only convex polyhedron that has four faces.
&mldr;</p></blockquote><blockquote><p>In the case of a tetrahedron the base is a triangle(any of the four faces can be considered the base), so a tetrahedron is also known as a &ldquo;triangular pyramid&rdquo;.
&mldr;</p></blockquote><p>For any tetrahedron there exists a sphere (the circumsphere) such that the tetrahedron&rsquo;s vertices lie on the sphere&rsquo;s surface.</p><p>The tetrahedron is also the simplest of the five <a href=http://en.wikipedia.org/wiki/Platonic_solid>platonic solids</a>. There are lots of interesting properties of these
but I don&rsquo;t really want to go into that here we just want to draw and texture one for now.</p><p>So how do we construct a tetrahedron?</p><p>There are various methods that can be used to construct a tetrahedron ranging from formula such as:</p><p>Cartesian coordinate based
(±1, 0, -1/sqrt2)
(0, ±1, 1/sqrt2)</p><p>V0 =(0,0,1)
V1=(2sqrt2 /3, 0, −1/3)<br>V2 =(− sqrt2 /3, sqrt6 /3, −1/3)<br>V3=(− sqrt2 /3,− sqrt6 /3,−1/3)</p><p>Yes I know I need to get latex maths expression working in my blog! Ill have to work on that.</p><p>I don&rsquo;t know about you, but I always feel uneasy unless I can clearly see exactly what&rsquo;s been done, I also don&rsquo;t
want to turn this into a 3D geometry lesson because that&rsquo;s not what I intend this post to be about.</p><p>Here&rsquo;s what works for me anyway.</p><p>Calculate the radius of the circumsphere, this is the sphere in which all of the vertices of the tetrahedron sit,
this is calculated by sqrt 3/8.</p><p>The angle between each vertex and its centre point is acos -1/3 or ~ 109.471 degrees.</p><ul><li>The first vertex is (0, sqrt (3/8) * length, 0)</li><li>To get our second vertex we need to rotate the first vertex by acos -1/3 in the X axis</li><li>To get the third vertex we rotate second vertex by 120 degrees in the Y axis</li><li>For the last vertex we rotate the second vertex by -120 degrees in the Y axis</li></ul><p>A picture can often be a worth a thousand words, I think this is one of those times, I will refer you to
<a href=http://www.f-lohmueller.de/pov_tut/x_sam/sam_440e.htm>Friedrich A. Lohmüllers site</a> for an excellent pictorial and description. The code for this process is below.</p><pre><code>let generateTetrahedron size = 
    let circumSphereRadius = sqrt (3.f/8.f) * size
    let centerVertexAngle = acos (-1.f/3.f)
    let v1 = Vector3(0.f, circumSphereRadius, 0.f)
    let v2 = v1 |&gt; Vector3.rotateX centerVertexAngle
    let v3 = v2 |&gt; Vector3.rotateY (radians 120.f)
    let v4 = v2 |&gt; Vector3.rotateY (-radians 120.f)
    
    let uv1 = Vector2(0.5f, 1.f - sqrt 0.75f)
    let uv2 = Vector2(0.75f, 1.f - (sqrt 0.75f)/2.f)
    let uv3 = Vector2(0.25f, 1.f - (sqrt 0.75f)/2.f)
    let uv4 = Vector2(0.5f, 1.f)
    let uv5 = Vector2.UnitY
    let uv6 = Vector2.One

    [| VertexPositionTexture(v1, uv1)
       VertexPositionTexture(v3, uv2)
       VertexPositionTexture(v2, uv3)  
       
       VertexPositionTexture(v1, uv2)
       VertexPositionTexture(v4, uv6)
       VertexPositionTexture(v3, uv4)

       VertexPositionTexture(v1, uv3)
       VertexPositionTexture(v2, uv4)
       VertexPositionTexture(v4, uv5)

       VertexPositionTexture(v2, uv3)
       VertexPositionTexture(v3, uv2)
       VertexPositionTexture(v4, uv4) |] 
</code></pre><p>The last piece of the puzzle is the texture coordinates. There is some amazing software available to help model both texture
and 3d geometry, projecting the vertices onto a 2d plane can be an art-form in itself. Luckily the tetrahedron is one
of the simplest models, if you imagine the tetrahedron unfolded it would look like this from the top:</p><figure class=third><img src=http://upload.wikimedia.org/wikipedia/commons/thumb/8/88/Tetrahedron_flat.svg/240px-Tetrahedron_flat.svg.png></figure><p>To map a texture to the tetrahedron we have to include a texture coordinate with every vertex. These coordinates are <code>uv1-uv6</code>
in the code above. We use some ratios to select the correct coordinates within the texture. The texture coordinates are always
between 0 and 1. Here&rsquo;s the location of the above points so you can see the locations clearly.</p><figure class=third><img src=https://lh4.googleusercontent.com/-NpV1nz3K-kI/ULKY-KY6emI/AAAAAAAABio/565nXCNC9xY/s425/texture+coords.png></figure><p>To make sure that the texture is in the right place we are going to use a type of fractal called the
<a href=http://en.wikipedia.org/wiki/Sierpinski_triangle>Sierpinski triangle</a>. The Sierpinski triangle had exactly the same net, or unfolded shape as the texture we need to use. Each
of the first iterations of the fractal is coloured separately as this will make it easy to see if the mapping is correct. Here
is what the texture looks like:</p><figure class=third><img src=https://lh4.googleusercontent.com/-hLyy6qGXjWc/ULKn_4p-CUI/AAAAAAAABjA/azvh8cUNrAY/s310/Tetrahedron.png></figure><p>This is how everything will look, I know its not incredibly impressive but its <a href=http://www.monogame.net>MonoGame</a> in 3d, F#, and all running on a
Mac, what more could you want! ;)</p><figure><img src=https://lh5.googleusercontent.com/-P_7wHvJbdY0/ULO2xNStVwI/AAAAAAAABjQ/SGA5DT4ChgU/s800/Screen+Shot+2012-11-26+at+18.33.57.png></figure><p>Its feels like we covered a lot of ground here but all we have is a spinning tetrahedron, its tricky to know what level of
detail to go down to. I don&rsquo;t want to teach anyone how to suck eggs, and I want to alienate people who are new
to this area and want to learn, I hope I got the balance about right.</p><p>If you want to just get the code and have a look then here&rsquo;s my <a href=https://github.com/7sharp9/PlatonicSolids>GitHub repo</a></p><p>As usual I appreciate any comments and feedback.</p><p>Until next time!</p></div></section><section class="pagination clearfix"><a class="btn previous" href=https://7sharp9.dev/fsharp/2012-11-11-fsharp-and-monogame-on-the-mac/>F# and MonoGame on the Mac</a>
<a class="btn next" href=https://7sharp9.dev/fsharp/2013-01-04-monogame-subdivision-and-platonics/>MonoGame subdivision and platonics</a></section><section id=disqus_thread class=disqus></section><script>var disqus_config=function(){this.page.url="https://7sharp9.dev/fsharp/2012-11-25-monogame-3d-basics/"};(function(){var a=document,b=a.createElement('script');b.src='//7sharp9.disqus.com/embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript></div><footer><div class="footer-info pull-right">© 2021 Dave Thomas</div></footer><script src=https://7sharp9.dev/js/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><script>(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)})(window,document,'script','//www.google-analytics.com/analytics.js','ga'),ga('create','UA-10152365-8','auto'),ga('send','pageview')</script></body></html>