<!doctype html><html><head><title>Can I have some F# with that? &#183; 7sharp9</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=generator content="Hugo 0.82.1"><link rel=stylesheet href=https://7sharp9.dev/css/vec.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.ico><link href rel=alternate type=application/rss+xml title=7sharp9></head><body><header><nav><ul><li class=pull-left><a href=https://7sharp9.dev/>/Home</a></li><li class=pull-left><a href=/about>/About</a></li><li class=pull-left><a href=/fsharp>/F#</a></li><li class=pull-left><a href=/running>/Running</a></li><li class=pull-left><a href=/elm>/Elm</a></li><li class=pull-right><a href><i class="fas fa-rss"></i></a></li></ul></nav></header><div class="content wide"><section class=post><h1 class=post-title><a href=https://7sharp9.dev/fsharp/2013-06-21-can-i-have-some-fsharp-with-that/>Can I have some F# with that?</a></h1><span class=post-date>Jun 21, 2013</span><div class=post-content><p><figure class="img-left sixth"><img src=http://scriptcs.net/images/logo@2x.png></figure>There&rsquo;s been a fair bit of activity lately from a project called <a href=http://scriptcs.net>ScriptCS</a>, it allows you to put together a project using C# as a lightweight scripting language, forgoing the use of Visual Studio which can sometimes be too bloated and bulky.</p><p>It also allows you to use C# in a Read Evaluate Print Loop - <a href=http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop>REPL</a>. This is nothing new to F# and indeed lots of other languages have REPL&rsquo;s too. One of the other benefits of ScriptCs is that it also integrates nicely with Nuget allowing you to use your favourite libraries quite easily. Finally there are Script Sacks which can be used to further reduce the amount of code you need to write when working with common frameworks.</p><p>It would be nice to leverage some of this new functionality from F#, and I don&rsquo;t like to see F# left out, especially when F# already has a REPL environment and is a really great language for scripting.</p><p>The F# compiler is also open source so we can utilize the code to add various tooling and features like refactoring, formatting, and analysis. See <a href=https://github.com/dungpa/fantomas>Fantomas</a>, <a href=https://github.com/Lewix/fsharp-refactor>FSharp-Refactor</a>, and the <a href=https://github.com/fsharp/fsharpbinding>FSharpBinding</a> for more details.</p><hr><h3 id=lets-get-to-work>Lets get to work</h3><p>The interface for adding a new script engines looks like this:</p><pre><code>public interface IScriptEngine
{
    string BaseDirectory { get; set; }
    ScriptResult Execute(string code, 
                         string[] scriptArgs, 
                         IEnumerable&lt;string&gt; references, 
                         IEnumerable&lt;string&gt; namespaces, 
                         ScriptPackSession scriptPackSession);
}
</code></pre><p>First lets create a new namespace and open up all the namespaces we need:</p><pre><code>namespace ScriptCs.Engine.FSharp
open ScriptCs
open Common.Logging
open System
open System.IO
open System.Collections.Generic
open Microsoft.FSharp.Compiler.Interactive.Shell
open ExtCore
open System.Linq
</code></pre><p>Next we need to store the result of an attempted expression evaluation. When we send code to an interactive session we might be in one of three different states:</p><ul><li>Incomplete - We have entereed a line but the expression is not complete, in F# we use <code>;;</code> to indicate the end of an expression.</li><li>Error - The entered expression resulted in an error.</li><li>Success - The expression that was entered was evaluated successfully.</li></ul><p>We can model this with a <a href=http://msdn.microsoft.com/en-us/library/dd233226.aspx>discriminated union</a> like this:</p><pre><code>type Result = 
| Success of String 
| Error of string 
| Incomplete
</code></pre><p>Next we will augment the existing <a href=https://github.com/fsharp/fsharp/blob/master/src/fsharp/fsi/fsi.fs#l2219>FsiEvaluationSession</a> type to allow it to be encapsulated and used by our interface.</p><pre><code>type FSharpEngine(host:ScriptHost) = 
   let stdin        = new StreamReader(System.IO.Stream.Null)
   let stdoutStream = new CompilerOutputStream()
   let stdout       = StreamWriter.Synchronized(new StreamWriter(stdoutStream, AutoFlush=true))
   let stderrStream = new CompilerOutputStream()
   let stderr       = StreamWriter.Synchronized(new StreamWriter(stderrStream, AutoFlush=true))
    
   let getOutput (session: FsiEvaluationSession) code = 

      let tryget() = 
         let error = stderrStream.Read()
         if error.Length &gt; 0 then Error(error) else
         Success(stdoutStream.Read())

      try session.EvalInteraction(code)
          if code.EndsWith &quot;;;&quot; then tryget() 
          else Incomplete
      with ex -&gt; Error ex.Message
        
   let commonOptions = [| &quot;fsi.exe&quot;; &quot;--nologo&quot;; &quot;--readline-&quot;|]
   let session = FsiEvaluationSession(commonOptions, stdin, stdout, stderr)

   let (&gt;&gt;=) (d1:#IDisposable) (d2:#IDisposable) = 
      {new IDisposable with member x.Dispose() = d1.Dispose(); d2.Dispose()}

   member x.Execute(code) = 
      getOutput session code

   member x.AddReference(ref) =
      session.EvalInteraction(sprintf &quot;#r @\&quot;%s\&quot;&quot; ref)

   member x.SilentAddReference(ref) = 
      x.AddReference(ref)
      stdoutStream.Read() |&gt; ignore

   member x.ImportNamespace(namespace') =
      session.EvalInteraction(sprintf &quot;open %s&quot; namespace')

   member x.SilentImportNamespace(namespace') =
      x.ImportNamespace(namespace')
      stdoutStream.Read() |&gt; ignore

   interface IDisposable with
      member x.Dispose() =
         (stdin &gt;&gt;= stdoutStream &gt;&gt;= stdout &gt;&gt;= stderrStream &gt;&gt;= stderr).Dispose()
</code></pre><p>We are mainly just wrapping the <code>FsiEvaluationSession</code> here, adding convenience methods to evaluate code and gather the output from the compiler streams. The current open source implementation of <code>FsiEvaluationSession</code> uses streams to add input and receive the output and errors. Stream processing makes sense when you are just dealing with a Console with in, out, and error streams, but it gets decidedly more complex if you want deterministic evaluation. Stream observation, polling, and looking for termination characters is fairly awkward to get right.</p><p>After a few conversations with <a href=http://blogs.msdn.com/b/dsyme/>Don Syme</a> he kindly assisted with an experimental version of <code>FsiEvaluationSession</code> that allowed expressions to be evaluated using the <code>EvalInteraction</code> and <code>EvalExpression</code> functions rather than writing directly to the input stream. I&rsquo;m very grateful for the work Don has done so far to help me with this. I think more work on hosted compilation will result in a lot of very useful tools and techniques.</p><p>You can also see in this section that I was also playing around with the symbolic operator <code>>>=</code> to compose together all the disposable streams at once. I suppose the inspiration for this (If you can call it that) is <a href=http://msdn.microsoft.com/en-us/data/gg577609.aspx>Reactive Extensions</a> which has a <a href="http://msdn.microsoft.com/en-us/library/system.reactive.disposables.compositedisposable(v=vs.103).aspx">CompositeDisposable</a>, and also the disposable computation builder that <a href=http://tomasp.net/blog/>Tomas Petricek</a> made available as <a href=http://www.fssnip.net>fssnip</a>. The <a href=http://msdn.microsoft.com/en-us/library/dd233237.aspx>object expression</a> that I used here seemed like a sensible option, and also shows the usefulness of object expressions.</p><p>Finally we implement the interface using the <code>FSharpEngine</code> as the type to be stored in the scripting session:</p><pre><code>type  FSharpScriptEngine( scriptHostFactory:IScriptHostFactory, logger: ILog) =
   let mutable baseDir = String.empty
   let [&lt;Literal&gt;]sessionKey = &quot;F# Session&quot;
   
   interface IScriptEngine with
      member x.BaseDirectory with get() = baseDir and set value = baseDir &lt;- value
      member x.Execute(code, args, references, namespaces, scriptPackSession) =
         let distinctReferences = references.Union(scriptPackSession.References).Distinct()
         let sessionState = 
            match scriptPackSession.State.TryGetValue sessionKey with
            | false, _ -&gt; let host = scriptHostFactory.CreateScriptHost(ScriptPackManager(scriptPackSession.Contexts), args)
                          logger.Debug(&quot;Creating session&quot;)
                          let session = new FSharpEngine(host)
                 
                          distinctReferences |&gt; Seq.iter (fun ref -&gt; logger.DebugFormat(&quot;Adding reference to {0}&quot;, ref)
                                                                     session.SilentAddReference ref )
                 
                          namespaces.Union(scriptPackSession.Namespaces).Distinct() 
                          |&gt; Seq.iter (fun ns -&gt; logger.DebugFormat(&quot;Importing namespace {0}&quot;, ns)
                                                 session.SilentImportNamespace ns)
                 
                          let sessionState = SessionState&lt;_&gt;(References = distinctReferences, Session = session)
                          scriptPackSession.State.Add(sessionKey, sessionState)
                          sessionState 
            | true, res -&gt; logger.Debug(&quot;Reusing existing session&quot;) 
                           let sessionState = res :?&gt; SessionState&lt;FSharpEngine&gt;
                           
                           let newReferences = match sessionState.References with
                                               | null -&gt; distinctReferences
                                               | refs when Seq.isEmpty refs -&gt; distinctReferences
                                               | refs -&gt;  distinctReferences.Except refs
                           newReferences |&gt; Seq.iter (fun ref -&gt; logger.DebugFormat(&quot;Adding reference to {0}&quot;, ref)
                                                                 sessionState.Session.AddReference ref ) 
                           sessionState      

         match sessionState.Session.Execute(code) with
         | Success result -&gt; let cleaned = 
                                result.Split([|&quot;\r&quot;; &quot;\n&quot;|], StringSplitOptions.RemoveEmptyEntries)
                                |&gt; Array.filter (fun str -&gt; not(str = &quot;&gt; &quot;))
                                |&gt; String.concat &quot;\r\n&quot;
                             ScriptResult(ReturnValue = cleaned)
         | Error e -&gt; ScriptResult(CompileException = exn e )
         | Incomplete -&gt; ScriptResult()
</code></pre><p>For the most part <code>Execute</code> is a simple port of the Roslyn implementation, mainly due to the way ScriptCs is currently implemented. There is a preprocessor that amongst other things parses reference additions <code>(#r)</code>, passing them down to the <code>Execute</code> method. I think eventually a registrable command plugin for ScriptCs will appear that will make custom REPL commands easy to add and configure.</p><p>Any new references are added in this snippet, where we leverage pattern matching.</p><pre><code>let newReferences = match sessionState.References with
                    | null -&gt; distinctReferences
                    | refs when Seq.isEmpty refs -&gt; distinctReferences
                    | refs -&gt;  distinctReferences.Except refs
newReferences |&gt; Seq.iter (fun ref -&gt; logger.DebugFormat(&quot;Adding reference to {0}&quot;, ref)
                                      sessionState.Session.AddReference ref )
</code></pre><p>Also of note is the final matching block <code>match sessionState.Session.Execute(code) with</code> we use pattern matching against the discriminated union that is returned by <code>Session.Execute(code)</code>. If <code>Execute</code> returns a <code>Success</code> we do a bit of a clean up on the result. We split the string based on carriage returns and newlines, filter out any prompts <code>> </code>, then reassemble the sting using <code>String.Concat</code>. We put this into the <code>Result</code> property of a <code>ScriptResult</code>. I do actually have a version of <code>FsiEvaluationSession</code> that suppresses prompts but I&rsquo;ve not merged that in yet. An <code>Error</code> results in the <code>CompileException</code> property being used on the <code>ScriptResult</code>. Finally if the expression is <code>Incomplete</code> we don&rsquo;t output a result or display an error as we are waiting for more input, we simply return an empty <code>ScriptResult</code>.</p><pre><code>match sessionState.Session.Execute(code) with
| Success result -&gt; let cleaned = 
                       result.Split([|&quot;\r&quot;; &quot;\n&quot;|], StringSplitOptions.RemoveEmptyEntries)
                       |&gt; Array.filter (fun str -&gt; not(str = &quot;&gt; &quot;))
                       |&gt; String.concat &quot;\r\n&quot;
                    ScriptResult(ReturnValue = cleaned)
| Error e -&gt; ScriptResult(CompileException = exn e )
| Incomplete -&gt; ScriptResult()
</code></pre><p>The final part is to plug this into ScriptSC, we do this by changing the <code>Initialize</code> method of <code>CompositionRoot</code>, all we need to do is Register our engine rather than the <code>RoslynScriptEngine</code> one:</p><pre><code>builder.RegisterType&lt;ScriptExecutor&gt;().As&lt;IScriptExecutor&gt;();
builder.RegisterType&lt;RoslynScriptEngine&gt;().As&lt;IScriptEngine&gt;();
</code></pre><p>To this:</p><pre><code>builder.RegisterType&lt;ScriptExecutor&gt;().As&lt;IScriptExecutor&gt;();
builder.RegisterType&lt;FSharpScriptEngine&gt;().As&lt;IScriptEngine&gt;();
</code></pre><p>And there we have it, hack session complete!</p><p>Several thing are missing from my implementation, namely debug support and script pack support. The guys over at ScriptCs are continuing to evolve the API to allow plugins like this to work properly. Multi-line support should be coming soon, if you run a REPL session using F# then a prompt is added when you hit return. There is also a GitHub issue raised to <a href=https://github.com/scriptcs/scriptcs/issues/346>add runtime packs for plugging in different runtimes/languages</a>, this will pave the way for ScriptCs to be available on Mono too <em>(If you disable the Roslyn based project and only use the F# Engine then it does actually work on Mono now.)</em>.</p><p>Once these issues are resolved in ScriptCs then hopefully F# will become a simple language plugin or even be merged into ScriptCs itself.</p><p>You can find my GitHub repository <a href=https://github.com/7sharp9/scriptcs>here</a>, feel free to hack away, add issues, pull requests are welcome too!</p><p>Until next time!</p></div></section><section class="pagination clearfix"><a class="btn previous" href=https://7sharp9.dev/fsharp/2013-06-05-monster-zero-revisited/>Monster Zero - Revisited</a>
<a class="btn next" href=https://7sharp9.dev/fsharp/2013-09-20-sprite-kit-particle-fun/>Spritekit particle fun</a></section><section id=disqus_thread class=disqus></section><script>var disqus_config=function(){this.page.url="https://7sharp9.dev/fsharp/2013-06-21-can-i-have-some-fsharp-with-that/"};(function(){var a=document,b=a.createElement('script');b.src='//7sharp9.disqus.com/embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript></div><footer><div class="footer-info pull-right">© 2021 Dave Thomas</div></footer><script src=https://7sharp9.dev/js/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><script>(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)})(window,document,'script','//www.google-analytics.com/analytics.js','ga'),ga('create','UA-10152365-8','auto'),ga('send','pageview')</script></body></html>