<!doctype html><html><head><title>Sockets and Bockets 1 &#183; 7sharp9</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=generator content="Hugo 0.82.1"><link rel=stylesheet href=https://7sharp9.dev/css/vec.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.ico><link href rel=alternate type=application/rss+xml title=7sharp9></head><body><header><nav><ul><li class=pull-left><a href=https://7sharp9.dev/>/Home</a></li><li class=pull-left><a href=/about>/About</a></li><li class=pull-left><a href=/fsharp>/F#</a></li><li class=pull-left><a href=/running>/Running</a></li><li class=pull-left><a href=/elm>/Elm</a></li><li class=pull-right><a href><i class="fas fa-rss"></i></a></li></ul></nav></header><div class="content wide"><section class=post><h1 class=post-title><a href=https://7sharp9.dev/fsharp/sockets-and-bockets-1/>Sockets and Bockets 1</a></h1><span class=post-date>Jan 13, 2011</span><div class=post-content><h3 id=welcome-to-part-1>Welcome to part 1</h3><p>A while back I read an interesting article by <em>Brian McNamara</em> <a href=http://lorgonblog.wordpress.com/2010/03/28/f-async-on-the-server-side/>f-async-on-the-server-side</a>
which describes C# and F# versions of a simple asynchronous
socket server, one of the driving forces behind the article was how F# can
wrap the traditional asynchronous model with <a href=http://msdn.microsoft.com/en-us/library/dd233250.aspx>Asynchronous Workflows</a>, this
produces nice clean simple code compared to the C# version which uses lambda
expressions, the code looks quite ugly in this style!  However thats not the
end of the story, a lot of memory fragmentation can occur using the APM model
when there is a high throughput, so I thought I would see if I could take this
a step further&mldr;</p><p>There are some lesser known methods that were added to the <a href=http://msdn.microsoft.com/en-us/library/system.net.sockets.socket.aspx>Socket</a>
class in .Net 2.0 SP1: ReceiveAsync, SendAsync, ConnectAsync and DisconnectAsync.
These methods use an event driven model and <strong>do not</strong> result in the creation
of AsyncResult objects, these are created on every asynchronous call in the
traditional Socket Begin/End methods.  Once you have thousands of clients
sending and receiving thousands of messages all of the object creation can
really have an adverse effect on performance on the garbage collected, you
will regularly see the AsyncResult objects hitting Generation 1 and 2.</p><p>To use the xxxAsync methods you have pass a <a href=http://msdn.microsoft.com/en-us/library/system.net.sockets.socketasynceventargs.aspx>SocketAsyncEventArgs</a>object which is
assigned callback method and a buffer, the callback method called
asynchronously when the operation completes and is passed the corresponding
SocketAsyncEventArgs object, this allows you query the buffer in a receive
operation.</p><p>The scope of this series of articles is to initially replicate Brian&rsquo;s demo
using F# and a pool of SocketAsyncEventArgs and a contiguous block of memory
to hold the data being sent and received on the Socket, this again further
reduces memory fragmentation on the send and receive buffers.</p><p>I have successfully developed an enterprise server for a client using this
method, it processed thousands of simultaneous connected clients and messages,
key components in the system were the High performance sockets, a pipeline
processor and a highly efficiency means of data compaction, I will only be
including the High performance sockets in this series but the other components
will be at a later date in separate articles.  Interestingly all of the code
was originally developed in c# but had a distinctly functional style, even the
Pipeline Processing is reminiscent of functional composition using the F#
pipeline operator <strong>|></strong> although an analogue of attach and detach was used
which in itself is declarative.</p><p>Although there is no code in this article there is plenty in the next!</p><p>Please feel free to leave comments or add any suggestions, hope to see you
next time&mldr;</p></div></section><section class="pagination clearfix"><a class="btn next" href=https://7sharp9.dev/fsharp/sockets-and-bockets-part-2/>Sockets and Bockets 2</a></section><section id=disqus_thread class=disqus></section><script>var disqus_config=function(){this.page.url="https://7sharp9.dev/fsharp/sockets-and-bockets-1/"};(function(){var a=document,b=a.createElement('script');b.src='//7sharp9.disqus.com/embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript></div><footer><div class="footer-info pull-right">© 2021 Dave Thomas</div></footer><script src=https://7sharp9.dev/js/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><script>(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)})(window,document,'script','//www.google-analytics.com/analytics.js','ga'),ga('create','UA-10152365-8','auto'),ga('send','pageview')</script></body></html>