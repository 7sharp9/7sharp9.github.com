<!doctype html><html><head><title>I want to tell you a storyboard &#183; 7sharp9</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=generator content="Hugo 0.82.1"><link rel=stylesheet href=https://7sharp9.dev/css/vec.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.ico><link href rel=alternate type=application/rss+xml title=7sharp9></head><body><header><nav><ul><li class=pull-left><a href=https://7sharp9.dev/>/Home</a></li><li class=pull-left><a href=/about>/About</a></li><li class=pull-left><a href=/fsharp>/F#</a></li><li class=pull-left><a href=/running>/Running</a></li><li class=pull-left><a href=/elm>/Elm</a></li><li class=pull-right><a href><i class="fas fa-rss"></i></a></li></ul></nav></header><div class="content wide"><section class=post><h1 class=post-title><a href=https://7sharp9.dev/fsharp/2017-04-11-i-want-to-tell-you-a-storyboard/>I want to tell you a storyboard</a></h1><span class=post-date>Apr 11, 2017</span><div class=post-content><p>So as promised here&rsquo;s a post with more detail on the iOS designer provider that I presented as part of my talk at <a href=https://skillsmatter.com/conferences/8053-f-sharp-exchange-2017>fsharpX 2017</a> The talk is entitled <a href=https://skillsmatter.com/skillscasts/10042-lightning-talk-session-expanding-the-horizons-of-mobile-development>Expanding the Horizons of Mobile Development</a></p><h1 id=background>Background</h1><p>In iOS, user interfaces can be represented by storyboards, essentially a storyboard is a big ball of xml that is produced by a visual designer like Xcode or Xamarin&rsquo;s Designer.</p><p>The basic premise of designer based user interfaces in .Net is the concept of a code behind file and and a partial class. For a C# Xamarin.iOS storyboard project something a bit like this will be present as a partial class:</p><pre><code>namespace Designer
{
  [Register (&quot;DesignerViewController&quot;)]
  partial class DesignerViewController
  {
    [Outlet]
    [GeneratedCodeAttribute (&quot;iOS Designer&quot;, &quot;1.0&quot;)]
    UIKit.UIButton submitButton { get; set; }

    void ReleaseDesignerOutlets ()
    {
      if (submitButton != null) {
        submitButton.Dispose ();
        submitButton = null;
      }
    }
  }
}
</code></pre><p>With the user using another file with the same partial class to consume the controls generated by the designer:</p><pre><code>namespace Designer
{
  partial class DesignerViewController
  {
      public override void ViewDidLoad ()
      {
        base.ViewDidLoad();
        submitButton.TouchUpInside += (sender, e) =&gt; {
            //Do stuff
        }
      }
  }
</code></pre><p>I&rsquo;ve always found the idea of partial class a bit of a cop out and never enjoyed having them around, which is why I do not miss them in F#. It does, however, pose a bit of problem with dealing with feature parity between C# and F# where designer files are generated as partial classes and you have to implement code in the other partial classes. In F# that whole aspect is entirely missing due to the lack of partial classes, which means anyone with a penchant for visual designers will be disappointed. <em>(You can read more about how the iOS designer works in Xamarin.iOS)</em> <a href=https://developer.xamarin.com/guides/ios/user_interface/designer/introduction/>here</a></p><h1 id=is-there-be-a-better-way>Is there be a better way?</h1><p>Of course! We can use the power of F# type providers! Although not for the feint hearted to create, F# type providers can be quite a boon to development time with their design time access to intellisense and tooltips based of some kind of underlying schema.</p><p>During my time at Xamarin I did research work on lots of different areas of using F#, one of those was using F# type providers with designer tooling for iOS and Android. A few weeks back <a href=https://twitter.com/migueldeicaza>Miguel de Icaza</a> kindly agreed to open source the work so that it could be enjoyed by all!</p><h1 id=introducing-the-ios-designer-provider>Introducing the iOS designer provider</h1><p>Type providers come in two distinct forms, generative and erasing, generally most people use erasing providers where the code is erased at compile time to objects leaving only raw functionality. This is particularly useful for large schemas where information is generated on demand or the runtime representation is only data and methods. Generative providers produce real types that can be consumed and augmented in the normal fashion. Due to the nature of the iOS runtime and the way the Xamarin iOS works, generative type providers are needed.</p><h2 id=how-does-it-work>How does it work?</h2><p>The storyboard files within the current project are processed and any <code>ViewControllers</code> that have been assigned a name are processed by the type provider. Each control within the <code>ViewController</code> are also processed if they have been assigned a name. A property and disposal logic is generated as well as an abstract type for the controller.</p><h2 id=example-storyboard>Example storyboard</h2><p>Here is a sample storyboard from tvOS:</p><p><img src=/img/designer-provider/tvOS-storyboard.png alt="tvOS storyboard"></p><p>The <code>ViewController</code> is named <code>ourViewController</code>. The controls are equally imaginatively named as follows:</p><ul><li>label1</li><li>entry1</li><li>entry2</li><li>entry3</li><li>entry4</li><li>button1</li></ul><h2 id=using-the-type-provider>Using the type provider</h2><p>The first step is to instantiate the type provider, this effectively starts the process of finding the storyboards within the project and generating the types in the background:</p><pre><code>type VCContainer = Xamarin.UIProvider
</code></pre><p>The type bound above <code>VCContainer</code> can be called anything you wish I named it <code>VCContainer</code> because it contains all of the <code>ViewControllers</code> found in the storyboards.</p><p>The next step is to create and register a <code>ViewController</code> that was defined in one of the storyboards. Using auto-completion we can <em>dot into</em> the <code>VCContainer</code> to find any of the <code>ViewControllers</code> within the storyboard.</p><p>Here the <code>ViewController</code> we saw in the screen shot above (<code>ourViewController</code>) is exposed with a <em>base</em> suffix <code>ourViewControllerBase</code> which is also an abstract type. We don&rsquo;t want to allow the <code>ViewController</code> to be instantiated directly as the iOS runtime requires attributes on the exposed type and as we don&rsquo;t yet have <a href=https://github.com/fsharp/fslang-suggestions/issues/509>intrinsic type extensions on provided types</a> we don&rsquo;t have a great alternative apart from inheritance or augmentation.</p><pre><code>[&lt;Register(VCContainer.ourViewControllerBase.CustomClass)&gt;]
type myViewController(ptr) =
    inherit VCContainer.ourViewControllerBase(ptr)
</code></pre><p>Due to the way Xamarin.iOS works we have to place a <code>Register</code> attribute on the type so that the the iOS runtime can instantiate the correct type when the storyboard is constructed. Another feature of the iOS designer type provider is that the <code>CustomClass</code> name is exposed as a convenience so that you don&rsquo;t have to remember or retype the name of the <code>ViewController</code> avoiding stringly typed hell. You can also see that <code>ourViewControllerBase</code> is called using the <code>nativeint</code> constructor: <code>inherit VCContainer.ourViewControllerBase(ptr)</code>, this is how the storyboard infrastructure in iOS creates an instance of your ViewController`.</p><p>When we come to wire up events and consume the controls we can do so very easily via auto completion. Say we want to wire up <code>button1</code> so that when it is clicked we concatenate the contents of the <code>Entry</code> controls and place the text into <code>label1</code> we could do so like this:</p><pre><code>    override x.ViewDidLoad () =
        base.ViewDidLoad ()
        x.button1.PrimaryActionTriggered.Add(
            fun _ -&gt; x.View.BackgroundColor &lt;- UIColor.Blue
                     x.label1.Text &lt;-
                        [ x.entry1.Text
                          x.entry2.Text
                          x.entry3.Text
                          x.entyr4.Text ]
                        |&gt; String.concat &quot; &quot; )
</code></pre><p>You can see in <code>ViewDidLoad</code> we added an event handler to <code>button1</code> and consume the relevant UI components.</p><h2 id=benefits>Benefits</h2><p>The benefits of this approach depend of what angle you look from. From the C# approach at the start of this post there&rsquo;s the reduced complexity of not having partial types and the designer generated parts being part of the project. You still get all the benefits of the UI controls being able to be consumed and available in auto completion etc. Compared to the current F# approach there&rsquo;s less boiler plate because you dont have to manually add properties and <code>Outlet</code> attributes to your <code>ViewController</code>, with this approach there&rsquo;s also the pitfall of stringly types which are extremly error prone. The final advantage is that if the storyboard is changed so that a control is deleted, the compilation will fail at design time rather than runtime.</p><p>Type providers provide a welcome safety net and boiler plate reduction for these type of scenarios.</p><h2 id=generated-code>Generated Code</h2><p>For the curious the generated code in <code>VCContainer</code> looks like this:</p><pre><code>public sealed class VCContainer
{
  public abstract class ourViewControllerBase : UIViewController
  {
    public const string CustomClass = &quot;ourViewController&quot;;
	private UITextField __entry1;
	private UITextField __entry2;
	private UITextField __entry3;
	private UITextField __entyr4;
	private UIButton __button1;
	private UILabel __label1;

	[Outlet]
	public UITextField entry1 {
		get {
		  return this.__entry1;
		}
		set {
		  this.__entry1 = value;
		}
	}

    //entry2/3/4 etc
}
</code></pre><p>Here is the disposal logic generated for each control:</p><pre><code>public void ReleaseDesignerOutlets () {
    if (this.__entry1 != null) {
        UnboxGeneric&lt;IDisposable&gt;(this.__entry1).Dispose ();
    }
    if (this.__entry2 != null) {
        UnboxGeneric&lt;IDisposable&gt;(this.__entry2).Dispose ();
    }
    if (this.__entry3 != null) {
        UnboxGeneric&lt;IDisposable&gt;(this.__entry3).Dispose ();
    }
    if (this.__entyr4 != null) {
        UnboxGeneric&lt;IDisposable&gt;(this.__entyr4).Dispose ();
    }
    if (this.__button1 != null) {
        UnboxGeneric&lt;IDisposable&gt;(this.__button1).Dispose ();
    }
    if (this.__label1 != null) {
        UnboxGeneric&lt;IDisposable&gt;(this.__label1).Dispose ();
    }
    if (this.__ourViewController != null) {
        UnboxGeneric&lt;IDisposable&gt;(this.__ourViewController).Dispose ();
    }
}
</code></pre><h1 id=so-whats-next>So whats next?</h1><p>Since <a href=https://skillsmatter.com/conferences/8053-f-sharp-exchange-2017>fsharpX</a> Ive been super busy catching up with work so I&rsquo;ve only managed to get the slides published for the talk and write this blog post, but fairly soon there will be a nuget package available that will allow the designer provider to be used for iOS, tvOS and watchOS. There is actually an experimental Android UI and fragment provider too, but that needs a little more work before its released on the general public :-)</p><p>If anyone is interested in the inner working of the type provider let me know and I&rsquo;ll draft up some notes on that too. I know type providers are pretty mysterious and advanced concepts to a lot of people, generative providers doubly so.</p><p>As usual I love to get <strong>any feedback</strong>, comments and suggestions&mldr;</p><p>Until next time!</p></div></section><section class="pagination clearfix"><a class="btn previous" href=https://7sharp9.dev/fsharp/2016-07-06-fable-fuse-template/>Creating fuse applications with fable</a>
<a class="btn next" href=https://7sharp9.dev/fsharp/2019-04-24-applied-metaprogramming-with-myriad/>Applied Meta-Programming</a></section></div><footer><div class="footer-info pull-right">© 2021 Dave Thomas</div></footer><script src=https://7sharp9.dev/js/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><script>(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)})(window,document,'script','//www.google-analytics.com/analytics.js','ga'),ga('create','UA-10152365-8','auto'),ga('send','pageview')</script></body></html>