<!doctype html><html><head><title>MonoTouch and F# part I &#183; 7sharp9</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=generator content="Hugo 0.82.1"><link rel=stylesheet href=https://7sharp9.dev/css/vec.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.ico><link href rel=alternate type=application/rss+xml title=7sharp9></head><body><header><nav><ul><li class=pull-left><a href=https://7sharp9.dev/>/Home</a></li><li class=pull-left><a href=/about>/About</a></li><li class=pull-left><a href=/fsharp>/F#</a></li><li class=pull-left><a href=/running>/Running</a></li><li class=pull-left><a href=/elm>/Elm</a></li><li class=pull-right><a href><i class="fas fa-rss"></i></a></li></ul></nav></header><div class="content wide"><section class=post><h1 class=post-title><a href=https://7sharp9.dev/fsharp/2013-02-03-monotouch-and-fsharp-part-i/>MonoTouch and F# part I</a></h1><span class=post-date>Feb 3, 2013</span><div class=post-content><p><a href=http://xamarin.com/monotouch>MonoTouch</a> and F# that would be a cool duo right?</p><p>Well let me explain what needs to be done and why to get this pair working together.</p><p>I heard rumours a while ago that F# and <a href=http://xamarin.com/monotouch>MonoTouch</a> would not play together nicely because of <a href=http://docs.xamarin.com/ios/about/limitations>limitations</a> in the ahead of time compilation <a href=http://www.mono-project.com/AOT>(AOT)</a>. So I thought I would either prove or disprove this with some concentrated hacking. How hard can it be?</p><p>As my good friend and colleague Dr. Kewin would quote:</p><blockquote><p>“No problem can withstand the assault of sustained thinking.”—Voltaire</p></blockquote><h2 id=prerequisites>Prerequisites</h2><p>These are the same as MonoTouch, I&rsquo;m using a Mac and MonoDevelop at the moment. You would need a Mac anyway to be able to do the compile and deploy to an iOS device. <a href=https://developer.apple.com/technologies/tools/>Xcode</a> with an Apple profile and certificates are required for code signing etc.</p><h2 id=first-steps>First steps</h2><p>So how do we tackle this?</p><p>First lets look at the <strong>C# Single View</strong> MonoTouch project file (<code>.csproj</code>) up to the end of the first PropertyGroup:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;Project DefaultTargets=&quot;Build&quot; ToolsVersion=&quot;4.0&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;
  &lt;PropertyGroup&gt;
    &lt;Configuration Condition=&quot; '$(Configuration)' == '' &quot;&gt;Debug&lt;/Configuration&gt;
    &lt;Platform Condition=&quot; '$(Platform)' == '' &quot;&gt;iPhoneSimulator&lt;/Platform&gt;
    &lt;ProductVersion&gt;10.0.0&lt;/ProductVersion&gt;
    &lt;SchemaVersion&gt;2.0&lt;/SchemaVersion&gt;
    &lt;ProjectGuid&gt;{822346B5-6805-42FD-9B6A-65446A688E63}&lt;/ProjectGuid&gt;
    &lt;ProjectTypeGuids&gt;{6BC8ED88-2882-458C-8E55-DFD12B67127B};
                      {FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&lt;/ProjectTypeGuids&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;RootNamespace&gt;HelloWorld&lt;/RootNamespace&gt;
    &lt;AssemblyName&gt;HelloWorld&lt;/AssemblyName&gt;
  &lt;/PropertyGroup&gt;
</code></pre><p>The bits we are interested in are the <strong>ProjectTypeGuids</strong>. Visual Studio/MonoDevelop projects use these guid&rsquo;s to identify the type of the project. If you do a bit of Googling <em>(or Binging&mldr;)</em> you would find that:</p><ul><li><strong>6BC8ED88-2882-458C-8E55-DFD12B67127B</strong> is a MonoTouch project type guid</li><li><strong>FAE04EC0-301F-11D3-BF4B-00C04F79EFBC</strong> is a C# project type guid</li></ul><p>The F# project type guid is <strong>F2A71F9B-5D33-465A-A702-920D77279786</strong>. We can now replace <strong>FAE04EC0-301F-11D3-BF4B-00C04F79EFBC</strong> with the F# one. For a comprehensive list of project type guid&rsquo;s have a look at <a href=http://workblog.pilin.name/2012/11/visual-studio-project-type-guids.html>Mikhail Pilin&rsquo;s blog</a>. Next scroll down to the bottom of the project file and update the to . the final step on the project file is to change the project file extension from <code>.csproj</code> to <code>.fsproj</code>.</p><p>The last of the tweaking is to open up the <code>.sln</code> file and make a slight change to that too:</p><pre><code>Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;singleview&quot;, &quot;singleview\singleview.fsproj&quot;, &quot;{4465399C-4EE8-4F60-AD9A-EB9AEDD1C5BF}&quot;
EndProject
Global
...snip...
</code></pre><p>Modify the Project sections Guid <strong>FAE04EC0-301F-11D3-BF4B-00C04F79EFBC</strong> to the F# project type Guid <strong>4925A630-B079-445d-BCD4-3A9C94FE9307</strong>. If you forget this step then MonoDevelop will get really confused and try to compile the F# project with the C# compiler.</p><h2 id=code-changes>Code Changes</h2><p>For the sake of simplicity I&rsquo;m going to port the C# code verbatim showing the C# code first then the F# code. The easiest way would probably be to change all the C# files to have the <code>.fs</code> extension and edit them in place, remembering to also update the entries in the <code>.fsproj</code> file too this only takes a second to do.</p><p>I know what you are going to say: &ldquo;Why didn&rsquo;t you just create a nice project template for us all to use?&rdquo;</p><p>I am, I am, patience!</p><p>A number of people wanted to know what I did to get things going so this is my documented &lsquo;hack-a-thon&rsquo; if you like. The project template will be along shortly. Lets move along to the code changes.</p><h2 id=viewcontroller>ViewController</h2><pre><code>using System;
using System.Drawing;
using MonoTouch.Foundation;
using MonoTouch.UIKit;

namespace singleview
{
	public partial class singleviewViewController : UIViewController
	{
		public singleviewViewController () : base (&quot;singleviewViewController&quot;, null)
		{
		}
		
		public override void DidReceiveMemoryWarning ()
		{
			// Releases the view if it doesn't have a superview.
			base.DidReceiveMemoryWarning ();
			// Release any cached data, images, etc that aren't in use.
		}
		
		public override void ViewDidLoad ()
		{
			base.ViewDidLoad ();
			// Perform any additional setup after loading the view, typically from a nib.
		}
		
		public override void ViewDidUnload ()
		{
			base.ViewDidUnload ();
			// Clear any references to subviews of the main view in order to
			// allow the Garbage Collector to collect them sooner.
			// e.g. myOutlet.Dispose (); myOutlet = null;
			ReleaseDesignerOutlets ();
		}
		
		public override bool ShouldAutorotateToInterfaceOrientation (UIInterfaceOrientation toInterfaceOrientation)
		{
			// Return true for supported orientations
			return (toInterfaceOrientation != UIInterfaceOrientation.PortraitUpsideDown);
		}
	}
}

// This file has been generated automatically by MonoDevelop to store outlets and
// actions made in the Xcode designer. If it is removed, they will be lost.
// Manual changes to this file may not be handled correctly.
using MonoTouch.Foundation;

namespace singleview
{
	[Register (&quot;singleviewViewController&quot;)]
	partial class singleviewViewController
	{
		void ReleaseDesignerOutlets ()
		{
		}
	}
}
</code></pre><pre><code>namespace Singleview

open System
open System.Drawing
open MonoTouch.Foundation
open MonoTouch.UIKit

[&lt;Register (&quot;singleviewViewController&quot;)&gt;]
type singleviewViewController() =
    inherit UIViewController(&quot;singleviewViewController&quot;, null)
        
    let ReleaseDesignerOutlets() = ( (* No outlets to release  *))

    override x.DidReceiveMemoryWarning() =
    // Releases the view if it doesn't have a superview.
        base.DidReceiveMemoryWarning();
        // Release any cached data, images, etc that aren't in use.

    override x.ViewDidLoad() =
        base.ViewDidLoad()
        // Perform any additional setup after loading the view, typically from a nib.

    override x.ViewDidUnload() =
        base.ViewDidUnload()
        // Clear any references to subviews of the main view in order to
        // allow the Garbage Collector to collect them sooner.
        // e.g. myOutlet.Dispose (); myOutlet = null;
        ReleaseDesignerOutlets()

    override x.ShouldAutorotateToInterfaceOrientation(toInterfaceOrientation) =
        // Return true for supported orientations
        toInterfaceOrientation &lt;&gt; UIInterfaceOrientation.PortraitUpsideDown
</code></pre><p>On looking at this section you will notice that there is no partial class in the F# version, that&rsquo;s because F# doesn&rsquo;t have any notion of partial classes. In this simple project we don&rsquo;t actually have any interaction with the UI so designer interaction is a moot point at the moment.</p><p>The <code>.fsproj</code> file still needs to be edited to remove the nested partial class that is present in the C# version:</p><pre><code>   &lt;Compile Include=&quot;singleviewViewController.designer.cs&quot;&gt;
      &lt;DependentUpon&gt;singleviewViewController.cs&lt;/DependentUpon&gt;
    &lt;/Compile&gt;
</code></pre><p>Simply remove the <code>DependUpon</code> element and just use the name <code>singleviewViewController.fs</code>:</p><pre><code>&lt;Compile&gt;singleviewViewController.fs/&gt;
</code></pre><p>The lack of partial classes in F# makes the tooling available for UI designer a pain to integrate tightly into F# without a bit of work work <em>(I have some ideas on that that I&rsquo;m currently experimenting with that Ill return to after finishing this article)</em>. Currently MonoTouch uses the Xcodes interface designer to build the UI which is stored in a xib file. This is simply a file describing the user interface and its interaction points. The Properties of the UI are called <code>Outlets</code> and events spawned from the UI are called <code>Actions</code>.</p><h2 id=appdelegate>AppDelegate</h2><pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using MonoTouch.Foundation;
using MonoTouch.UIKit;

namespace singleview
{
	// The UIApplicationDelegate for the application. This class is responsible for launching the 
	// User Interface of the application, as well as listening (and optionally responding) to 
	// application events from iOS.
	[Register (&quot;AppDelegate&quot;)]
	public partial class AppDelegate : UIApplicationDelegate
	{
		// class-level declarations
		UIWindow window;
		singleviewViewController viewController;

		// This method is invoked when the application has loaded and is ready to run. In this 
		// method you should instantiate the window, load the UI into it and then make the window visible.
		// You have 17 seconds to return from this method, or iOS will terminate your application.
		public override bool FinishedLaunching (UIApplication app, NSDictionary options)
		{
			window = new UIWindow (UIScreen.MainScreen.Bounds);
			
			viewController = new singleviewViewController ();
			window.RootViewController = viewController;
			window.MakeKeyAndVisible ();
			
			return true;
		}
	}
}
</code></pre><pre><code>namespace Singleview
open System
open System.Collections.Generic
open MonoTouch.Foundation
open MonoTouch.UIKit

// The UIApplicationDelegate for the application. This class is responsible for launching the 
// User Interface of the application, as well as listening (and optionally responding) to application events from iOS.
[&lt;Register (&quot;AppDelegate&quot;)&gt;]
type AppDelegate() =
    inherit UIApplicationDelegate()
    
    let mutable window = Unchecked.defaultof&lt;_&gt;
    let mutable viewController = Unchecked.defaultof&lt;_&gt;

    // This method is invoked when the application has loaded and is ready to run. In this 
    // method you should instantiate the window, load the UI into it and then make the window visible.
    // You have 17 seconds to return from this method, or iOS will terminate your application.
    override x.FinishedLaunching ( app: UIApplication,  options: NSDictionary) =
        window &lt;- new UIWindow(UIScreen.MainScreen.Bounds)
        viewController &lt;- new singleviewViewController()
        window.RootViewController &lt;- viewController
        window.MakeKeyAndVisible()
        true
</code></pre><p>The code is pretty similar between the two implementations, with the F# version omitting the type annotations, semicolons and curly braces. The other area to notice is that the <code>mutable</code> variable declarations for the <code>window</code> and <code>viewController</code> bindings. The C# implementation defaults to mutable variables whereas F# defaults to the safer immutable ones.</p><h2 id=programmain>Program/main</h2><pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using MonoTouch.Foundation;
using MonoTouch.UIKit;

namespace singleview
{
	public class Application
	{
		// This is the main entry point of the application.
		static void Main (string[] args)
		{
			// if you want to use a different Application Delegate class from &quot;AppDelegate&quot;
			// you can specify it here.
			UIApplication.Main (args, null, &quot;AppDelegate&quot;);
		}
	}
}
</code></pre><pre><code>module main
open System
open System.Collections.Generic
open MonoTouch.Foundation
open MonoTouch.UIKit

    [&lt;EntryPoint&gt;]
    let main( args) = 
        UIApplication.Main (args, null, &quot;AppDelegate&quot;)
        0
</code></pre><p>The main thing you will notice is that the F# code is terser, again dropping the type annotations, semicolons and curly braces. Oh, I also called the entry point main. To be precise it&rsquo;s a function called main in a module named main, there&rsquo;s no need to create a class or type for this.</p><h2 id=the-xib-file>The Xib file</h2><p>In C# MonoToch projects the <code>xib</code> file is compiled and embedded for you as part of the build process, unfortunately this is not currently possible in F# so we have to do it manually. In an ideal world this would all be done by the F# project at build time and this is something that I&rsquo;m working on too. In the mean time we have to do it manually so open up your trusty friend the <code>Terminal</code>.</p><p>I&rsquo;m going to split the command line into separate parts due to its size:</p><p>First of all we invoke the <code>ibtool</code>:</p><pre><code>/Applications/Xcode.app/Contents/Developer/usr/bin/ibtool --errors --warnings --notices --output-format human-readable-text --compile
</code></pre><p>Followed by name of the <code>.nib</code> file you want to compile to:</p><pre><code>&quot;/yourPath/singleviewViewController.nib&quot;
</code></pre><p>The path of the <code>.xib</code> you want to compile from:</p><pre><code>&quot;/yourPath/singleviewViewController.xib&quot;
</code></pre><p>Finally the sdk that you want to use for compilation, in this instance it is The iPhoneSimulator6.0.sdk as we are targetting the simulator:
&ndash;sdk &ldquo;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator6.0.sdk&rdquo;</p><p>Once you have compiled to a <code>.nib</code> file include it in the project, set the build action to <code>Content</code>. You can still include the <code>.xib</code> version within the project if you want but you would have to set the build action to <code>None</code>. Currently the F# binding does not support the build action of <code>Interface Definition</code> if it did then we probably wouldn&rsquo;t have to go through the manual compilation process either.</p><p>That ought to do it, everything should now work on the simulator. If you try to compile to a real phone then everything will quickly come grinding to a halt but Ill explain all of that next time and how to resolve it too.</p><p>Until next time!</p></div></section><section class="pagination clearfix"><a class="btn previous" href=https://7sharp9.dev/fsharp/2013-01-04-monogame-subdivision-and-platonics/>MonoGame subdivision and platonics</a>
<a class="btn next" href=https://7sharp9.dev/fsharp/2013-02-04-monotouch-and-fsharp-part-ii/>MonoTouch and F# part II</a></section><section id=disqus_thread class=disqus></section><script>var disqus_config=function(){this.page.url="https://7sharp9.dev/fsharp/2013-02-03-monotouch-and-fsharp-part-i/"};(function(){var a=document,b=a.createElement('script');b.src='//7sharp9.disqus.com/embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript></div><footer><div class="footer-info pull-right">© 2021 Dave Thomas</div></footer><script src=https://7sharp9.dev/js/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><script>(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)})(window,document,'script','//www.google-analytics.com/analytics.js','ga'),ga('create','UA-10152365-8','auto'),ga('send','pageview')</script></body></html>